<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Barnstormer â€“ Rings + Horses (dust) + Radio Towers + Dynamic Lighting + Lanes + Audio</title>
  <style>
    html,body{height:100%;margin:0;background:#87CEEB;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    canvas{display:block;margin:0 auto;image-rendering:crisp-edges;image-rendering:-webkit-optimize-contrast;}
    #hud{position:fixed;left:10px;top:10px;color:#111;background:rgba(255,255,255,.6);padding:6px 10px;border-radius:8px;font-weight:600}
  </style>
</head>
<body>
  <div id="hud">W/S: Climb/Dive â€¢ A/D: loop â€¢ Shift: speed boost â€¢ Space: fire
    <button id="mute" style="margin-left:8px;border:0;background:#fff;border-radius:6px;padding:4px 8px;cursor:pointer">ðŸ”Š</button>
  </div>
  <canvas id="game"></canvas>
  <script type="module">
    const canvas=document.getElementById('game');
    const ctx=canvas.getContext('2d');
    function resize(){
      const dpr=Math.max(2,window.devicePixelRatio||1);
      canvas.width=innerWidth*dpr;
      canvas.height=innerHeight*dpr;
      canvas.style.width=innerWidth+'px';
      canvas.style.height=innerHeight+'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    resize();
    addEventListener('resize',resize);

    // === State ===
    const w=()=>canvas.clientWidth, h=()=>canvas.clientHeight;
    const CAMERA_X = 150; // fixed on-screen x for the plane (camera follows world)
    const plane={x:CAMERA_X,y:h()/2,baseSpeed:1.2,boostSpeed:3,propAngle:0,angle:0,
      // looping state: some legacy fields kept for compatibility
      loop:false, loopProgress:0, loopDir:0, loopCenterY:h()/2, loopRadius:80, loopSpeed:0.02,
      // crash state
      alive:true, crashed:false
    };
    let paused = false;
    let rings=[],groundElements=[],clouds=[],dustParticles=[],bullets=[];
    let lastGroundType=null; // prevent repeating the same ground element type consecutively
    const DIST_RING=420,DIST_GROUND=520,DIST_CLOUD=220;
    let distRing=0,distGround=0,distCloud=0;
    let frameCount=0;

    const keys={};
    addEventListener('keydown',e=>{ const k=e.key.toLowerCase(); keys[k]=true; if(!audioInited) initAudio(); if(k===' '||k==='space'){ fireBullet(); e.preventDefault(); }});
    addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });

    function currentScrollSpeed(){return keys['shift']?plane.boostSpeed:plane.baseSpeed;}

    // === Lighting helpers (dynamic sky & ground) ===
    let sunlightAngle=0; // drives time-of-day and shadow direction
    let stars = [];
    // persistent randomized moon craters (relative positions + sizes)
    let moonCraters = null; // [{dxFrac, dyFrac, rFrac}] fractions of moon radius
    function generateMoonCraters(count){
      moonCraters = [];
      const maxAttempts = 800;
      let attempts = 0;
      let overlapsUsed = 0; // allow up to two overlaps total
      while(moonCraters.length < count && attempts < maxAttempts){
        attempts++;
        const angle = Math.random()*Math.PI*2;
        const offsetR = 0.22 + Math.random()*0.58; // 0.22..0.80 of radius
        const dxFrac = offsetR * Math.cos(angle);
        const dyFrac = offsetR * Math.sin(angle);
        const rFrac = 0.06 + Math.random()*0.16; // 6%..22% of radius
        // measure overlaps this candidate would introduce
        let overlapCount = 0;
        for(const c of moonCraters){
          const d = Math.hypot(dxFrac - c.dxFrac, dyFrac - c.dyFrac);
          if(d < (rFrac + c.rFrac) * 1.05){ overlapCount++; }
        }
        if(overlapCount === 0 || overlapsUsed + overlapCount <= 2){
          moonCraters.push({dxFrac, dyFrac, rFrac});
          overlapsUsed += overlapCount;
        }
      }
    }
    const clamp01=x=>Math.max(0,Math.min(1,x));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const lerpColor=(c1,c2,t)=>{
      t=clamp01(t);
      const r=Math.round(lerp(c1[0],c2[0],t));
      const g=Math.round(lerp(c1[1],c2[1],t));
      const b=Math.round(lerp(c1[2],c2[2],t));
      return [r,g,b];
    };
    const lerpColorStr=(c1,c2,t)=>{
      const rgb=lerpColor(c1,c2,t);
      return `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
    };
    // simple seeded RNG (mulberry32) for deterministic cloud shapes
    function makeRNG(seed){
      return function(){
        seed = (seed + 0x6D2B79F5) | 0;
        let t = Math.imul(seed ^ (seed >>> 15), 1 | seed);
        t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
    const dayToDuskT=()=>clamp01((Math.sin(sunlightAngle- Math.PI/2)+1)/2); // 0 midday -> 1 dusk
    const sunPhase=()=>clamp01((Math.sin(sunlightAngle)+1)/2); // 0 night -> 1 day

    function generateStars(count){
      stars = [];
      for(let i=0;i<count;i++){
        stars.push({ x: Math.random()*w(), y: Math.random()*h()*0.55, size: Math.random()*1.8+0.2, alpha: Math.random()*0.9 });
      }
    }
    let lastTime = null;
    const dayDuration = 60; // seconds for a full day/night cycle

    function drawSky(){
      const t=dayToDuskT();
      const sun = sunPhase();
      const top = lerpColorStr([135,206,235],[20,20,48], 1 - sun); // blue day -> dark night
      const bot = lerpColorStr([176,224,255],[10,10,30], 1 - sun);
      const g=ctx.createLinearGradient(0,0,0,h());
      g.addColorStop(0,top); g.addColorStop(1,bot);
      ctx.fillStyle=g; ctx.fillRect(0,0,w(),h());

      // sun during day (soft glow) and stars/moon at night
      const nightFactor = 1 - sun;
      // sun path: move the sun along an arc across the sky using sunlightAngle
      if(sun > 0.2){
        const sunArcX = w()*0.5 + Math.cos(sunlightAngle - Math.PI/2) * (w()*0.38);
        const sunArcY = h()*0.22 + Math.sin(sunlightAngle - Math.PI/2) * (h()*0.16);
        // radial glow
        const rg = ctx.createRadialGradient(sunArcX, sunArcY, 6, sunArcX, sunArcY, 120);
        rg.addColorStop(0, 'rgba(255,250,200,0.95)'); rg.addColorStop(0.2, 'rgba(255,235,120,0.6)'); rg.addColorStop(0.6, 'rgba(255,200,80,0.12)'); rg.addColorStop(1, 'rgba(255,200,80,0)');
        ctx.fillStyle = rg; ctx.beginPath(); ctx.arc(sunArcX, sunArcY, 120, 0, Math.PI*2); ctx.fill();
        // core
        ctx.fillStyle = 'rgba(255,245,180,1)'; ctx.beginPath(); ctx.arc(sunArcX, sunArcY, 22, 0, Math.PI*2); ctx.fill();
      }

      if(nightFactor > 0.2){
        ctx.save();
        ctx.globalAlpha = Math.min(0.9, nightFactor*1.2);
        for(const s of stars){ ctx.fillStyle = `rgba(255,255,255,${s.alpha*nightFactor})`; ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill(); }
        // moon (opposite the sun)
        const moonX = w()*0.5 - Math.cos(sunlightAngle - Math.PI/2) * (w()*0.38);
        const moonY = h()*0.22 - Math.sin(sunlightAngle - Math.PI/2) * (h()*0.16);
        const moonRadius = 50.4; // 80% larger than original 28
        // Draw moon fully opaque (not affected by outer globalAlpha)
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.fillStyle = 'rgb(180,180,185)';
        ctx.beginPath(); ctx.arc(moonX, moonY, moonRadius, 0, Math.PI*2); ctx.fill();
        
        // craters on moon: generate once and render randomized sizes (added 2 more vs original)
        if(!moonCraters){ generateMoonCraters(9); }
        for(const c of (moonCraters||[])){
          const absR = c.rFrac * moonRadius;
          const cx = moonX + c.dxFrac * moonRadius;
          const cy = moonY + c.dyFrac * moonRadius;
          const isLarge = c.rFrac > 0.12;
          const alpha = (isLarge ? 0.85 : 0.75) * nightFactor;
          // diagonal gradient (top-left to bottom-right across crater)
          const grd = ctx.createLinearGradient(cx - absR, cy - absR, cx + absR, cy + absR);
          const lightRGB = isLarge ? [135,135,155] : [140,140,160];
          const midRGB   = isLarge ? [100,100,120] : [105,105,125];
          const darkRGB  = isLarge ? [65,65,85] : [70,70,90];
          grd.addColorStop(0, `rgba(${lightRGB[0]},${lightRGB[1]},${lightRGB[2]},${alpha})`);
          grd.addColorStop(0.6, `rgba(${midRGB[0]},${midRGB[1]},${midRGB[2]},${alpha})`);
          grd.addColorStop(1, `rgba(${darkRGB[0]},${darkRGB[1]},${darkRGB[2]},${alpha})`);
          ctx.fillStyle = grd;
          ctx.beginPath(); ctx.arc(cx, cy, absR, 0, Math.PI*2); ctx.fill();
        }
        // end opaque moon context
        ctx.restore();
        
        ctx.restore();
      }

      const groundColor=lerpColorStr([34,139,34],[12,40,12], 1 - sun);
      ctx.fillStyle=groundColor; ctx.fillRect(0,h()-60,w(),60);
    }

    // === Spawners ===
    function spawnClouds(){
      const num=Math.floor(Math.random()*3)+1;
      for(let i=0;i<num;i++){
        const size=24+Math.random()*56;
        const variation = Math.random(); // seed for shape randomization
        const lobes = 3 + Math.floor(Math.random()*4); // 3-6 cloud puffs
        const curlStrength = 0.3 + Math.random()*0.4; // how curvy the cloud is
        const seed = (Math.random()*0xFFFFFFFF)>>>0;
        clouds.push({x:w()+80+Math.random()*160,y:20+Math.random()*(h()*0.5-40),size,variation,lobes,curlStrength,seed});
      }
    }

    // helper: weighted random type, but avoid repeating prev type
    function pickElementType(prev){
      const weighted = ()=>{
        const r=Math.random();
        return (r<0.09)?'farmhouse':(r<0.18)?'office':(r<0.32)?'barn':(r<0.62)?'tree':(r<0.71)?'radio':(r<0.83)?'silo':'water';
      };
      let t = weighted();
      let tries=0;
      while(t===prev && tries<4){ t = weighted(); tries++; }
      if(t===prev){
        const all=['farmhouse','office','barn','tree','radio','silo','water'];
        const others=all.filter(x=>x!==prev);
        t = others[Math.floor(Math.random()*others.length)];
      }
      return t;
    }

    function spawnGroundElements(){
      // choose 1-3 elements, non-overlapping, extra spacing rules (barn-tree, horses)
      const count=Math.floor(Math.random()*3)+1;
      for(let i=0;i<count;i++){
        // type distribution including radio, silo, water and horse (avoid repeating last type)
        let type = pickElementType(lastGroundType);
        // sizes â€” choose ranges appropriate to the element type
        // Height hierarchy: horses < trees < farmhouse < barn < silo < water tower, office < radio tower
        let baseW, baseH;
        if(type === 'tree'){
          // trees: taller than horses, shorter than farmhouse
          baseW = 18 + Math.random()*20; // 18..38
          baseH = 50 + Math.random()*80; // 50..130
        } else if(type === 'radio'){
          // radio towers: tallest
          baseW = 10 + Math.random()*10; // 10..20 (thinner)
          baseH = 180 + Math.random()*200; // 180..380
        } else if(type === 'horse'){
          // horses: smallest, low-profile objects
          baseW = 28 + Math.random()*24; // 28..52
          baseH = 14 + Math.random()*14; // 14..28
        } else if(type === 'office'){
          // office buildings: taller than silo, comparable to water tower
          baseW = 80 + Math.random()*100; // 80..180
          baseH = 180 + Math.random()*140; // 180..320
        } else if(type === 'barn'){
          // barns: taller than farmhouse, shorter than silo
          baseW = 120 + Math.random()*60; // 120..180
          baseH = 100 + Math.random()*60; // 100..160
        } else if(type === 'farmhouse'){
          // farmhouse: taller than trees, shorter than barn
          baseW = 60 + Math.random()*70; // 60..130
          baseH = 60 + Math.random()*40; // 60..100
        } else if(type === 'silo'){
          // silo: taller than barn, shorter than water tower
          baseW = 55 + Math.random()*35; // 55..90
          baseH = 180 + Math.random()*50; // 180..230
        } else if(type === 'water'){
          // water tower: taller than silo, shorter than radio towers
          baseW = 50 + Math.random()*20; // 50..70
          baseH = 160 + Math.random()*15; // 160..175 (always shorter than min radio tower of 180)
        } else {
          // fallback block
          baseW = 50 + Math.random()*40;
          baseH = 50 + Math.random()*50;
        }
            let newX = w()+100+Math.random()*200;
            const pad=40, extraBarnTree=100, extraHorseGap=60;
            const groundY=h()-60-baseH;
            // If a generated position overlaps existing ground elements, shift it right until it fits.
            // Use a safety cap to avoid infinite loops.
            let safety = 0;
            // adjacency constraints for certain types (both directions)
            const allowedNeighbors = {
              silo: new Set(['barn','farmhouse']),
              farmhouse: new Set(['barn','silo']),
              barn: new Set(['farmhouse','silo','horse']),
              radio: new Set([]), // radio towers must have no neighbors
              water: new Set(['barn','farmhouse','tree','office','silo','radio']), // water towers can't be next to each other
              office: new Set(['farmhouse','tree','water','radio']), // office can't be next to silo
              horse: new Set(['barn']) // horses only near barns
            };
            function isAdjacencyAllowed(aType, bType){
              if(bType==null) return true;
              const aRule = allowedNeighbors[aType];
              const bRule = allowedNeighbors[bType];
              if(aRule && !aRule.has(bType)) return false;
              if(bRule && !bRule.has(aType)) return false;
              return true;
            }
            function neighborsAt(x){
              let left=null, right=null;
              let leftGap=Infinity, rightGap=Infinity;
              for(const eg of groundElements){
                const gapLeft = x - (eg.x + eg.width);
                const gapRight = eg.x - (x + baseW);
                if(gapLeft >= 0 && gapLeft < leftGap){ left=eg; leftGap=gapLeft; }
                if(gapRight >= 0 && gapRight < rightGap){ right=eg; rightGap=gapRight; }
              }
              return {left, right, leftGap, rightGap};
            }
            const adjThreshold = 80; // consider elements within this edge gap as "next to"
            while(true){
              const overlap = groundElements.find(g=>{
                const centerA = g.x + g.width/2;
                const centerB = newX + baseW/2;
                    const barnTreeGap = ((g.type==='barn'&&type==='tree')||(g.type==='tree'&&type==='barn')) ? extraBarnTree : 0;
                    const horseAvoid = ((g.type==='horse'&&type!=='horse')||(type==='horse'&&g.type!=='horse')) ? extraHorseGap : 0;
                    const siloAvoid = ((g.type==='silo'&&type!=='silo')||(type==='silo'&&g.type!=='silo')) ? 120 : 0;
                    const waterAvoid = ((g.type==='water'&&type!=='water')||(type==='water'&&g.type!=='water')) ? 100 : 0;
                    const radioAvoid = ((g.type==='radio'&&type!=='radio')||(type==='radio'&&g.type!=='radio')) ? 150 : 0;
                    const barnSiloAvoid = ((g.type==='barn'&&type==='silo')||(g.type==='silo'&&type==='barn')) ? 50 : 0;
                    const siloOfficeAvoid = ((g.type==='silo'&&type==='office')||(g.type==='office'&&type==='silo')) ? 140 : 0;
                    const radioFarmhouseAvoid = ((g.type==='radio'&&type==='farmhouse')||(g.type==='farmhouse'&&type==='radio')) ? 140 : 0;
                    const radioWaterAvoid = ((g.type==='radio'&&type==='water')||(g.type==='water'&&type==='radio')) ? 140 : 0;
                    const radioBarnAvoid = ((g.type==='radio'&&type==='barn')||(g.type==='barn'&&type==='radio')) ? 140 : 0;
                    const farmhouseWaterAvoid = ((g.type==='farmhouse'&&type==='water')||(g.type==='water'&&type==='farmhouse')) ? 140 : 0;
                    const radioSiloAvoid = ((g.type==='radio'&&type==='silo')||(g.type==='silo'&&type==='radio')) ? 140 : 0;
                    const radioHorseAvoid = ((g.type==='radio'&&type==='horse')||(g.type==='horse'&&type==='radio')) ? 140 : 0;
                    const barnWaterAvoid = ((g.type==='barn'&&type==='water')||(g.type==='water'&&type==='barn')) ? 140 : 0;
                    const waterSiloAvoid = ((g.type==='water'&&type==='silo')||(g.type==='silo'&&type==='water')) ? 140 : 0;
                    const farmhouseSiloAvoid = ((g.type==='farmhouse'&&type==='silo')||(g.type==='silo'&&type==='farmhouse')) ? 40 : 0;
                const minGap = (g.width/2 + baseW/2 + pad + barnTreeGap + horseAvoid + siloAvoid + waterAvoid + radioAvoid + barnSiloAvoid + siloOfficeAvoid + radioFarmhouseAvoid + radioWaterAvoid + radioBarnAvoid + farmhouseWaterAvoid + radioSiloAvoid + radioHorseAvoid + barnWaterAvoid + waterSiloAvoid + farmhouseSiloAvoid);
                return Math.abs(centerA - centerB) < minGap;
              });
              if(!overlap) break;
              // Move newX to just beyond the overlapping element's edge
              const barnTreeGap = ((overlap.type==='barn'&&type==='tree')||(overlap.type==='tree'&&type==='barn')) ? extraBarnTree : 0;
              const horseAvoid = ((overlap.type==='horse'&&type!=='horse')||(type==='horse'&&overlap.type!=='horse')) ? extraHorseGap : 0;
              const siloAvoid = ((overlap.type==='silo'&&type!=='silo')||(type==='silo'&&overlap.type!=='silo')) ? 120 : 0;
              const waterAvoid = ((overlap.type==='water'&&type!=='water')||(type==='water'&&overlap.type!=='water')) ? 100 : 0;
              const radioAvoid = ((overlap.type==='radio'&&type!=='radio')||(type==='radio'&&overlap.type!=='radio')) ? 150 : 0;
              const barnSiloAvoid = ((overlap.type==='barn'&&type==='silo')||(overlap.type==='silo'&&type==='barn')) ? 50 : 0;
              const siloOfficeAvoid = ((overlap.type==='silo'&&type==='office')||(overlap.type==='office'&&type==='silo')) ? 140 : 0;
              const radioFarmhouseAvoid = ((overlap.type==='radio'&&type==='farmhouse')||(overlap.type==='farmhouse'&&type==='radio')) ? 140 : 0;
              const radioWaterAvoid = ((overlap.type==='radio'&&type==='water')||(overlap.type==='water'&&type==='radio')) ? 140 : 0;
              const radioBarnAvoid = ((overlap.type==='radio'&&type==='barn')||(overlap.type==='barn'&&type==='radio')) ? 140 : 0;
              const farmhouseWaterAvoid = ((overlap.type==='farmhouse'&&type==='water')||(overlap.type==='water'&&type==='farmhouse')) ? 140 : 0;
              const radioSiloAvoid = ((overlap.type==='radio'&&type==='silo')||(overlap.type==='silo'&&type==='radio')) ? 140 : 0;
              const radioHorseAvoid = ((overlap.type==='radio'&&type==='horse')||(overlap.type==='horse'&&type==='radio')) ? 140 : 0;
              const barnWaterAvoid = ((overlap.type==='barn'&&type==='water')||(overlap.type==='water'&&type==='barn')) ? 140 : 0;
              const waterSiloAvoid = ((overlap.type==='water'&&type==='silo')||(overlap.type==='silo'&&type==='water')) ? 140 : 0;
              const farmhouseSiloAvoid = ((overlap.type==='farmhouse'&&type==='silo')||(overlap.type==='silo'&&type==='farmhouse')) ? 40 : 0;
              const minGap = (overlap.width/2 + baseW/2 + pad + barnTreeGap + horseAvoid + siloAvoid + waterAvoid + radioAvoid + barnSiloAvoid + siloOfficeAvoid + radioFarmhouseAvoid + radioWaterAvoid + radioBarnAvoid + farmhouseWaterAvoid + radioSiloAvoid + radioHorseAvoid + barnWaterAvoid + waterSiloAvoid + farmhouseSiloAvoid);
              newX = overlap.x + overlap.width/2 + baseW/2 + pad + barnTreeGap + horseAvoid + 10;
              safety++;
              if(safety>50){
                // fallback: place further to the right
                newX += 200 + Math.random()*200;
                break;
              }
            }
            // enforce adjacency rules for barn/farmhouse/silo
            let adjSafety = 0;
            while(true){
              const {left, right, leftGap, rightGap} = neighborsAt(newX);
              const leftType = (left && leftGap <= adjThreshold) ? left.type : null;
              const rightType = (right && rightGap <= adjThreshold) ? right.type : null;
              const okLeft = isAdjacencyAllowed(type, leftType);
              const okRight = isAdjacencyAllowed(type, rightType);
              if(okLeft && okRight) break;
              // nudge right to find a valid neighbor configuration
              newX += 60;
              adjSafety++;
              if(adjSafety>40) { newX += 200; break; }
            }
        const phase=(type==='horse')?Math.random()*Math.PI*2:0;
        const elem = {x:newX,y:groundY,width:baseW,height:baseH,type,phase};
        groundElements.push(elem);
        lastGroundType = type;
        if(type==='barn'){ 
          elem.doorProgress = 0; 
          elem.doorTarget = 0;
          // Add 1-2 horses near the barn with fence (added after to avoid adjacency issues)
          const numHorses = Math.random() < 0.7 ? 1 : 2;
          for(let hi=0; hi<numHorses; hi++){
            const horseW = 28 + Math.random()*24;
            const horseH = 14 + Math.random()*14;
            const horseX = newX + baseW + 80 + hi*100;
            const horseY = h()-60-horseH;
            const horsePhase = Math.random()*Math.PI*2;
            const horseElem = {x:horseX, y:horseY, width:horseW, height:horseH, type:'horse', phase:horsePhase, hasFence:true};
            groundElements.push(horseElem);
          }
        }
        if(type==='tree'){
          // per-tree shape params to get variation while drawing
          elem.trunkWidth = Math.max(3, Math.round(baseW * (0.12 + Math.random()*0.12))); // small trunk
          elem.canopyCount = 2 + Math.floor(Math.random()*3); // 2..4 clumps
          elem.canopyR = Math.max(12, Math.round(baseW * (0.9 + Math.random()*0.6))); // radius for canopy clumps
          elem.canopyYOffset = Math.round(baseH * (0.18 + Math.random()*0.18));
          elem.canopySpread = Math.round(baseW * (0.4 + Math.random()*0.8));
          elem.leafHueShift = (Math.random()*0.2 - 0.1); // small color variation
          elem.variantSeed = Math.random();
        }
      }
    }

    // Rings: 5 vertical levels within the top 3/5 of the screen
    const ringLevels=()=>{
      const top=h()*0.1; // leave headroom
      const step=(h()*0.6 - top)/4; // top 60%
      return [0,1,2,3,4].map(i=>top + i*step);
    };
    function spawnRing(){
      const levels=ringLevels();
      const i = Math.floor(Math.random()*levels.length);
      const y = levels[i];
      const laneName = `Ring ${i+1}`; // 1..5 top->bottom
      const ringRadius = 30;
      const ringX = w() + 80;
      
      // check if ring would collide with any building
      let collides = false;
      for(const g of groundElements){
        const dx = ringX - (g.x + g.width/2);
        const dy = y - (g.y + g.height/2);
        const dist = Math.hypot(dx, dy);
        const minDist = ringRadius + Math.max(g.width, g.height)/2 + 20; // buffer zone
        if(dist < minDist){
          collides = true;
          break;
        }
      }
      
      // only spawn if no collision
      if(!collides){
        rings.push({x:ringX,y,radius:ringRadius,glow:0,collected:false,lane:i+1,name:laneName});
      }
    }

    // === Drawing helpers ===
    function drawCloud(c){
      const t=dayToDuskT();
      const rng = makeRNG(c.seed||12345);
      // base color with slight per-cloud brightness variation
      const baseRGB = lerpColor([255,255,255],[255,230,210],t);
      const shadeK = 0.95 + rng()*0.1; // 0.95..1.05 (less variation)
      const bR = Math.max(0, Math.min(255, Math.round(baseRGB[0]*shadeK)));
      const bG = Math.max(0, Math.min(255, Math.round(baseRGB[1]*shadeK)));
      const bB = Math.max(0, Math.min(255, Math.round(baseRGB[2]*shadeK)));
      const lightCol = `rgba(${bR},${bG},${bB},${0.96})`;
      const midCol   = `rgba(${Math.round(bR*0.94)},${Math.round(bG*0.94)},${Math.round(bB*0.94)},${0.96})`;
      const darkCol  = `rgba(${Math.round(bR*0.85)},${Math.round(bG*0.85)},${Math.round(bB*0.85)},${0.96})`;

      // number of puffs, based on lobes plus a bit of randomness
      const n = Math.max(4,(c.lobes||4) + Math.floor(rng()*3)); // lobes..lobes+2
      for(let i=0;i<n;i++){
        const xoff = (rng()*1.4 - 0.7) * c.size;
        const yoff = (rng()*0.6 - 0.3) * c.size * (0.5 + (c.curlStrength||0.4));
        const rx = c.size * (0.45 + rng()*0.6);
        const ry = rx * (0.6 + rng()*0.25);
        // diagonal gradient per puff (top-left to bottom-right)
        const g = ctx.createLinearGradient(c.x + xoff - rx, c.y + yoff - ry, c.x + xoff + rx, c.y + yoff + ry);
        g.addColorStop(0, lightCol);
        g.addColorStop(0.55, midCol);
        g.addColorStop(1, darkCol);
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.ellipse(c.x + xoff, c.y + yoff, rx, ry, 0, 0, Math.PI*2);
        ctx.fill();
      }

      // randomized shadow detail along the bottom to add depth
      const shadowRGB = lerpColor([220,225,235],[240,210,190],t);
      const sR = Math.round(shadowRGB[0]*0.9), sG = Math.round(shadowRGB[1]*0.9), sB = Math.round(shadowRGB[2]*0.9);
      ctx.fillStyle = `rgba(${sR},${sG},${sB},${0.25 + rng()*0.2})`;
      ctx.beginPath();
      ctx.ellipse(c.x - c.size*(0.45+rng()*0.1), c.y + c.size*(0.18+rng()*0.08), c.size*(0.45+rng()*0.1), c.size*(0.32+rng()*0.08), 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(c.x + c.size*(0.45+rng()*0.1), c.y + c.size*(0.18+rng()*0.08), c.size*(0.5+rng()*0.1), c.size*(0.36+rng()*0.08), 0, 0, Math.PI*2);
      ctx.fill();
    }

    function shadeColorRGB(rgb, amt){
      const k=1-amt; return `rgb(${Math.round(rgb[0]*k)},${Math.round(rgb[1]*k)},${Math.round(rgb[2]*k)})`;
    }

    function drawGroundElement(g){
      const t=dayToDuskT();
      const shadowLen=lerp(3,12,t);
      const sx=Math.cos(sunlightAngle)*shadowLen;
      const sy=Math.sin(sunlightAngle)*shadowLen;

      if(g.type==='farmhouse'){
        // body
        ctx.save();
        const wall=[222,184,135];
        ctx.shadowColor='rgba(0,0,0,0.35)'; ctx.shadowBlur=5; ctx.shadowOffsetX=sx; ctx.shadowOffsetY=sy;
        ctx.fillStyle=shadeColorRGB(wall, t*0.25); ctx.fillRect(g.x,g.y,g.width,g.height);
        ctx.shadowColor='transparent';
        
        // horizontal siding
        ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 1;
        const sidingSpacing = 8;
        for(let y = g.y + sidingSpacing; y < g.y + g.height; y += sidingSpacing){
          ctx.beginPath();
          ctx.moveTo(g.x + 2, y);
          ctx.lineTo(g.x + g.width - 2, y);
          ctx.stroke();
        }
        
        // outline
        ctx.strokeStyle='rgba(0,0,0,0.85)'; ctx.lineWidth=1; ctx.strokeRect(g.x,g.y,g.width,g.height);
        // door
        const dW=g.width*0.2,dH=g.height*0.4,dX=g.x+g.width*0.4,dY=g.y+g.height*0.6;
        ctx.fillStyle=shadeColorRGB([139,69,19],t*0.3); ctx.fillRect(dX,dY,dW,dH);
        ctx.strokeRect(dX,dY,dW,dH);
        
        // doorknob
        const knobX = dX + dW * 0.8;
        const knobY = dY + dH * 0.5;
        ctx.fillStyle = '#d4af37'; // gold color
        ctx.beginPath();
        ctx.arc(knobX, knobY, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.6)';
        ctx.lineWidth = 0.5;
        ctx.stroke();
        
        // windows with dynamic reflection and night glow
        const winW=g.width*0.2,winH=g.height*0.25;
        const windows=[{x:g.x+g.width*0.1,y:g.y+g.height*0.25},{x:g.x+g.width*0.7,y:g.y+g.height*0.25}];
        windows.forEach(wi=>{
          // window color transitions from blue (day) to warm yellow (night)
          const nightGlow = t > 0.5 ? (t - 0.5) * 2 : 0; // glow factor for night
          const dayColor = 'rgba(255,255,255,0.85)';
          const nightColor = `rgba(255,240,150,${0.7 + nightGlow * 0.3})`; // warmer and brighter at night
          const blendColor = t < 0.5 ? dayColor : nightColor;
          
          const grad=ctx.createLinearGradient(wi.x,wi.y,wi.x,wi.y+winH);
          grad.addColorStop(0, blendColor);
          grad.addColorStop(0.4, t < 0.5 ? '#b0e0ff' : `rgba(255,220,100,${0.8 + nightGlow * 0.2})`);
          grad.addColorStop(1, t < 0.5 ? '#87ceeb' : `rgba(255,210,80,${0.6 + nightGlow * 0.2})`);
          ctx.fillStyle=grad; ctx.fillRect(wi.x,wi.y,winW,winH);
          
          ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1; ctx.strokeRect(wi.x,wi.y,winW,winH);
          
          // cross-shaped window braces
          ctx.strokeStyle = 'rgba(0,0,0,0.7)'; ctx.lineWidth = 1.5;
          // vertical brace
          ctx.beginPath();
          ctx.moveTo(wi.x + winW / 2, wi.y);
          ctx.lineTo(wi.x + winW / 2, wi.y + winH);
          ctx.stroke();
          // horizontal brace
          ctx.beginPath();
          ctx.moveTo(wi.x, wi.y + winH / 2);
          ctx.lineTo(wi.x + winW, wi.y + winH / 2);
          ctx.stroke();
          
          // specular highlight
          ctx.fillStyle='rgba(255,255,255,0.18)'; ctx.fillRect(wi.x+winW*0.12, wi.y+winH*0.08, winW*0.5, winH*0.18);
        });
        // roof with shingles - black
        ctx.fillStyle=shadeColorRGB([20,20,20],t*0.25);
        ctx.beginPath(); ctx.moveTo(g.x,g.y); ctx.lineTo(g.x+g.width/2,g.y-18); ctx.lineTo(g.x+g.width,g.y); ctx.closePath(); ctx.fill();
        ctx.strokeStyle='rgba(0,0,0,0.65)'; ctx.lineWidth=1; ctx.stroke();
        
        // black shingles
        ctx.fillStyle = 'rgba(30,30,30,0.6)';
        const shingleHeight = 3;
        const shingleWidth = 8;
        const roofPeakX = g.x + g.width / 2;
        const roofPeakY = g.y - 18;
        
        // left side shingles
        for(let row = 0; row < 6; row++){
          const y = roofPeakY + row * shingleHeight;
          const leftX = roofPeakX - (row + 1) * (g.width / 2 / 6);
          const rightX = roofPeakX;
          const rowWidth = rightX - leftX;
          const numShingles = Math.ceil(rowWidth / shingleWidth);
          const offsetX = (row % 2) * (shingleWidth / 2);
          
          for(let i = 0; i < numShingles; i++){
            const sx = leftX + i * shingleWidth + offsetX;
            if(sx < roofPeakX){
              ctx.fillRect(sx, y, shingleWidth - 0.5, shingleHeight - 0.5);
            }
          }
        }
        
        // right side shingles
        for(let row = 0; row < 6; row++){
          const y = roofPeakY + row * shingleHeight;
          const leftX = roofPeakX;
          const rightX = roofPeakX + (row + 1) * (g.width / 2 / 6);
          const rowWidth = rightX - leftX;
          const numShingles = Math.ceil(rowWidth / shingleWidth);
          const offsetX = (row % 2) * (shingleWidth / 2);
          
          for(let i = 0; i < numShingles; i++){
            const sx = leftX + i * shingleWidth + offsetX;
            if(sx + shingleWidth > leftX && sx < rightX){
              ctx.fillRect(sx, y, shingleWidth - 0.5, shingleHeight - 0.5);
            }
          }
        }
        
        ctx.restore();
        return;
      }

      if(g.type==='office'){
        ctx.save();
        ctx.shadowColor='rgba(0,0,0,0.35)'; ctx.shadowBlur=5; ctx.shadowOffsetX=sx; ctx.shadowOffsetY=sy;
        ctx.fillStyle=shadeColorRGB([150,150,150], t*0.3); ctx.fillRect(g.x,g.y,g.width,g.height);
        ctx.shadowColor='transparent';
        // outline building
        ctx.strokeStyle='rgba(0,0,0,0.85)'; ctx.lineWidth=1; ctx.strokeRect(g.x,g.y,g.width,g.height);
        // draw window grid
        const cols = Math.max(4, Math.floor(g.width / 28));
        const rows = Math.max(2, Math.floor(g.height / 32));
        const winW = Math.min(24, Math.max(12, Math.floor((g.width - (cols+1)*6) / cols)));
        const winH = Math.min(20, Math.max(12, Math.floor((g.height - (rows+1)*6) / rows)));
        const gapX = (g.width - cols*winW) / (cols+1);
        const gapY = (g.height - rows*winH) / (rows+1);
        for(let ry=0; ry<rows-1; ry++){
          for(let cx=0; cx<cols; cx++){
            const wx = Math.round(g.x + gapX + cx*(winW+gapX));
            const wy = Math.round(g.y + gapY + ry*(winH+gapY));
            // windows get warmer and brighter toward dusk/night
            const nightGlow = t > 0.5 ? (t - 0.5) * 2 : 0; // glow intensity for night
            const winColor = lerpColor([40,45,55],[255,240,150], t);
            const winAlpha = 0.9 + nightGlow * 0.2; // brighter at night
            // reflective vertical gradient: bright at top to window color
            const wg = ctx.createLinearGradient(wx, wy, wx, wy+winH);
            wg.addColorStop(0, t < 0.5 ? 'rgba(255,255,255,0.9)' : `rgba(255,255,200,${winAlpha})`);
            wg.addColorStop(0.18, `rgba(${winColor[0]},${winColor[1]},${winColor[2]},${winAlpha})`);
            const bottomColor = lerpColor([20,25,30],[220,180,100], t);
            wg.addColorStop(1, `rgb(${bottomColor[0]},${bottomColor[1]},${bottomColor[2]})`);
            ctx.fillStyle = wg;
            ctx.fillRect(wx, wy, winW, winH);
            
            ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth=1; ctx.strokeRect(wx, wy, winW, winH);
            
            // subtle specular highlight (top-left)
            ctx.fillStyle = 'rgba(255,255,255,0.16)';
            ctx.fillRect(wx + Math.round(winW*0.12), wy + Math.round(winH*0.08), Math.round(winW*0.45), Math.round(winH*0.16));
          }
        }
        
        // Draw door in center of ground floor
        const doorW = Math.min(28, g.width * 0.2);
        const doorH = Math.min(40, g.height * 0.18);
        const doorX = g.x + (g.width - doorW) / 2;
        const doorY = g.y + g.height - doorH;
        
        // door frame
        ctx.fillStyle = shadeColorRGB([80,80,80], t*0.35);
        ctx.fillRect(doorX, doorY, doorW, doorH);
        ctx.strokeStyle = 'rgba(0,0,0,0.85)'; ctx.lineWidth = 1.5;
        ctx.strokeRect(doorX, doorY, doorW, doorH);
        
        // door panels (two vertical panels)
        ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 1;
        ctx.strokeRect(doorX + 2, doorY + 2, doorW/2 - 3, doorH - 4);
        ctx.strokeRect(doorX + doorW/2 + 1, doorY + 2, doorW/2 - 3, doorH - 4);
        
        // doorknob
        const knobSize = 2;
        const knobX = doorX + doorW * 0.65;
        const knobY = doorY + doorH * 0.5;
        ctx.fillStyle = shadeColorRGB([180,180,120], t*0.2);
        ctx.beginPath();
        ctx.arc(knobX, knobY, knobSize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        return;
      }

      if(g.type==='tree'){
        ctx.save();
        // ground shadow ellipse
        ctx.fillStyle='rgba(0,0,0,0.22)';
        ctx.beginPath(); ctx.ellipse(g.x+g.width*0.5+sx, g.y+g.height+4+sy, g.width*0.7, g.width*0.22, 0,0,Math.PI*2); ctx.fill();
        // trunk
        ctx.fillStyle=shadeColorRGB([101,67,33], t*0.25);
        const tw = g.trunkWidth || Math.max(3, Math.round(g.width*0.18));
        const trunkX = Math.round(g.x + (g.width - tw)/2);
        const trunkY = Math.round(g.y + g.height*0.35);
        const trunkH = Math.round(g.height*0.65);
        ctx.fillRect(trunkX, trunkY, tw, trunkH);
        ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1; ctx.strokeRect(trunkX, trunkY, tw, trunkH);
        // canopy: multiple clumps using per-tree params
        const leafBase = lerpColorStr([46,139,87],[20,70,40],t);
        for(let i=0;i<(g.canopyCount||3);i++){
          const seed = (g.variantSeed||0.5) * 10 + i*1.37;
          const cx = Math.round(g.x + g.width*0.5 + (i - ((g.canopyCount||3)-1)/2) * (g.canopySpread || (g.width*0.6)) / (g.canopyCount||3));
          const cy = Math.round(g.y + (g.canopyYOffset || g.height*0.25) - i*6);
          const r = Math.round((g.canopyR || Math.max(12, g.width*0.6)) * (0.8 + 0.35 * Math.sin(seed)));
          const lcT = clamp01(t + (g.leafHueShift || 0));
          const leafColor = lerpColorStr([46,139,87],[20,70,40], lcT);
          ctx.fillStyle = leafColor;
          ctx.beginPath(); ctx.ellipse(cx, cy, r, Math.round(r*0.8), 0, 0, Math.PI*2); ctx.fill();
        }
        // outline canopy rough
        ctx.strokeStyle='rgba(0,0,0,0.45)'; ctx.lineWidth=1;
        const outlineCx = g.x+g.width*0.5, outlineCy = g.y+g.height*0.25, outlineR = Math.max(g.width,g.height*0.45)*0.55;
        ctx.beginPath(); ctx.ellipse(outlineCx, outlineCy, outlineR, outlineR*0.78, 0, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
        return;
      }

      if(g.type==='radio'){
        const baseX=g.x+g.width/2, topY=g.y, botY=g.y+g.height;
        
        // Guide wires (3 on each side) - draw first so they're behind the tower
        ctx.strokeStyle='rgba(100,100,100,0.4)'; ctx.lineWidth=1;
        const guideHeights = [0.3, 0.5, 0.7]; // attachment points as fractions of tower height
        for(let i=0; i<3; i++){
          const attachY = topY + g.height * guideHeights[i];
          // Left side guide wire
          ctx.beginPath();
          ctx.moveTo(baseX - g.width/2 - 30, botY);
          ctx.lineTo(baseX - g.width*0.2 - (g.width*0.3 * (1-guideHeights[i])), attachY);
          ctx.stroke();
          // Right side guide wire
          ctx.beginPath();
          ctx.moveTo(baseX + g.width/2 + 30, botY);
          ctx.lineTo(baseX + g.width*0.2 + (g.width*0.3 * (1-guideHeights[i])), attachY);
          ctx.stroke();
        }
        
        // Tower structure
        ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(baseX-g.width/2,botY); ctx.lineTo(baseX-g.width*0.2,topY);
        ctx.moveTo(baseX+g.width/2,botY); ctx.lineTo(baseX+g.width*0.2,topY);
        for(let y=0;y<g.height;y+=12){ const yPos=botY-y; const t=(y/g.height); const half=lerp(g.width/2,g.width*0.2,t); ctx.moveTo(baseX-half,yPos); ctx.lineTo(baseX+half,yPos-6); }
        ctx.stroke();
        
        // Top antenna point
        const pointY = topY - 12;
        ctx.strokeStyle='rgba(0,0,0,0.7)'; ctx.lineWidth=2;
        ctx.beginPath();
        ctx.moveTo(baseX, topY-6);
        ctx.lineTo(baseX, pointY);
        ctx.stroke();
        
        // Red light on top
        ctx.fillStyle='#ff0000'; 
        ctx.beginPath(); 
        ctx.arc(baseX, topY-6, 4, 0, Math.PI*2); 
        ctx.fill();
        // Light glow
        ctx.fillStyle='rgba(255,0,0,0.3)';
        ctx.beginPath();
        ctx.arc(baseX, topY-6, 7, 0, Math.PI*2);
        ctx.fill();
        
        // outline base block
        ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1; ctx.strokeRect(g.x, g.y, g.width, g.height);
        return;
      }

      if(g.type==='barn'){
        const shadowLen=lerp(3,12,t);
        const sx=Math.cos(sunlightAngle)*shadowLen;
        const sy=Math.sin(sunlightAngle)*shadowLen;
        ctx.save();
        ctx.fillStyle='#8b0000'; ctx.fillRect(g.x,g.y,g.width,g.height);
        // siding: vertical boards
        ctx.save();
        const boardCount = Math.max(4, Math.floor(g.width / 18));
        ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1.5;
        for(let i=1;i<boardCount;i++){
          const bx = Math.round(g.x + i*(g.width/boardCount));
          ctx.beginPath(); ctx.moveTo(bx, g.y+6); ctx.lineTo(bx, g.y+g.height-6); ctx.stroke();
        }
        ctx.restore();
        ctx.shadowColor='rgba(0,0,0,0.5)'; ctx.shadowBlur=6; ctx.shadowOffsetX=sx; ctx.shadowOffsetY=sy;
        ctx.strokeStyle='rgba(0,0,0,0.85)'; ctx.lineWidth=1; ctx.strokeRect(g.x,g.y,g.width,g.height);
        ctx.shadowColor='transparent';
        
        // Ground level double doors
        const groundDoorW = Math.max(50, Math.floor(g.width * 0.5));
        const groundDoorH = Math.max(40, Math.floor(g.height * 0.45));
        const groundDoorY = g.y + g.height - groundDoorH;
        const groundDoorCenterX = g.x + g.width / 2;
        const groundClosedLeft = groundDoorCenterX - groundDoorW / 2;
        const groundOpenOffset = Math.round((groundDoorW / 2 + 4) * (g.doorProgress || 0));
        
        // Left door slides left, right door slides right
        const leftDoorX = groundClosedLeft - groundOpenOffset;
        const rightDoorX = groundDoorCenterX + groundOpenOffset;
        
        // Clear the aperture (opening between doors)
        const apertureW = groundOpenOffset * 2;
        if(apertureW > 0){
          ctx.clearRect(groundDoorCenterX - apertureW/2, groundDoorY - 2, apertureW, groundDoorH + 4);
        }
        
        // Draw left door
        ctx.save();
        ctx.fillStyle = shadeColorRGB([110,60,30], t*0.2);
        ctx.fillRect(leftDoorX, groundDoorY, groundDoorW/2, groundDoorH);
        ctx.strokeStyle = 'rgba(0,0,0,0.85)'; ctx.lineWidth = 1; ctx.strokeRect(leftDoorX, groundDoorY, groundDoorW/2, groundDoorH);
        // X brace on left door
        ctx.strokeStyle = 'rgba(0,0,0,0.95)'; ctx.lineWidth = 2;
        ctx.beginPath(); 
        ctx.moveTo(leftDoorX + 4, groundDoorY + 4); 
        ctx.lineTo(leftDoorX + groundDoorW/2 - 4, groundDoorY + groundDoorH - 4); 
        ctx.moveTo(leftDoorX + groundDoorW/2 - 4, groundDoorY + 4); 
        ctx.lineTo(leftDoorX + 4, groundDoorY + groundDoorH - 4); 
        ctx.stroke();
        
        // Draw right door
        ctx.fillStyle = shadeColorRGB([110,60,30], t*0.2);
        ctx.fillRect(rightDoorX, groundDoorY, groundDoorW/2, groundDoorH);
        ctx.strokeStyle = 'rgba(0,0,0,0.85)'; ctx.lineWidth = 1; ctx.strokeRect(rightDoorX, groundDoorY, groundDoorW/2, groundDoorH);
        // X brace on right door
        ctx.strokeStyle = 'rgba(0,0,0,0.95)'; ctx.lineWidth = 2;
        ctx.beginPath(); 
        ctx.moveTo(rightDoorX + 4, groundDoorY + 4); 
        ctx.lineTo(rightDoorX + groundDoorW/2 - 4, groundDoorY + groundDoorH - 4); 
        ctx.moveTo(rightDoorX + groundDoorW/2 - 4, groundDoorY + 4); 
        ctx.lineTo(rightDoorX + 4, groundDoorY + groundDoorH - 4); 
        ctx.stroke();
        ctx.restore();
        
        // Second level smaller double doors (always closed)
        const upperDoorW = Math.max(30, Math.floor(g.width * 0.3));
        const upperDoorH = Math.max(24, Math.floor(g.height * 0.25));
        const upperDoorY = g.y + g.height * 0.2;
        const upperDoorCenterX = g.x + g.width / 2;
        const upperClosedLeft = upperDoorCenterX - upperDoorW / 2;
        
        const upperLeftDoorX = upperClosedLeft;
        const upperRightDoorX = upperDoorCenterX;
        
        // Draw upper left door
        ctx.save();
        ctx.fillStyle = shadeColorRGB([110,60,30], t*0.2);
        ctx.fillRect(upperLeftDoorX, upperDoorY, upperDoorW/2, upperDoorH);
        ctx.strokeStyle = 'rgba(0,0,0,0.85)'; ctx.lineWidth = 1; ctx.strokeRect(upperLeftDoorX, upperDoorY, upperDoorW/2, upperDoorH);
        // X brace on upper left door
        ctx.strokeStyle = 'rgba(0,0,0,0.95)'; ctx.lineWidth = 1.5;
        ctx.beginPath(); 
        ctx.moveTo(upperLeftDoorX + 3, upperDoorY + 3); 
        ctx.lineTo(upperLeftDoorX + upperDoorW/2 - 3, upperDoorY + upperDoorH - 3); 
        ctx.moveTo(upperLeftDoorX + upperDoorW/2 - 3, upperDoorY + 3); 
        ctx.lineTo(upperLeftDoorX + 3, upperDoorY + upperDoorH - 3); 
        ctx.stroke();
        
        // Draw upper right door
        ctx.fillStyle = shadeColorRGB([110,60,30], t*0.2);
        ctx.fillRect(upperRightDoorX, upperDoorY, upperDoorW/2, upperDoorH);
        ctx.strokeStyle = 'rgba(0,0,0,0.85)'; ctx.lineWidth = 1; ctx.strokeRect(upperRightDoorX, upperDoorY, upperDoorW/2, upperDoorH);
        // X brace on upper right door
        ctx.strokeStyle = 'rgba(0,0,0,0.95)'; ctx.lineWidth = 1.5;
        ctx.beginPath(); 
        ctx.moveTo(upperRightDoorX + 3, upperDoorY + 3); 
        ctx.lineTo(upperRightDoorX + upperDoorW/2 - 3, upperDoorY + upperDoorH - 3); 
        ctx.moveTo(upperRightDoorX + upperDoorW/2 - 3, upperDoorY + 3); 
        ctx.lineTo(upperRightDoorX + 3, upperDoorY + upperDoorH - 3); 
        ctx.stroke();
        ctx.restore();
        
        // Roof - half octagon shape
        ctx.fillStyle=shadeColorRGB([165,42,42], t*0.25);
        ctx.beginPath();
        const roofBaseY = g.y;
        const roofPeakY = g.y - 30;
        const roofLeft = g.x;
        const roofRight = g.x + g.width;
        const roofCenterX = g.x + g.width / 2;
        const seg = g.width / 4; // segment width for octagon sides
        
        // Start at bottom left
        ctx.moveTo(roofLeft, roofBaseY);
        // First angled side (bottom left to mid-left)
        ctx.lineTo(roofLeft + seg * 0.3, roofBaseY - seg * 0.4);
        // Second angled side (mid-left to upper-left)
        ctx.lineTo(roofLeft + seg * 0.7, roofPeakY + seg * 0.3);
        // Top left to peak
        ctx.lineTo(roofCenterX - seg * 0.4, roofPeakY);
        // Peak to top right
        ctx.lineTo(roofCenterX + seg * 0.4, roofPeakY);
        // Upper-right angled
        ctx.lineTo(roofRight - seg * 0.7, roofPeakY + seg * 0.3);
        // Mid-right angled
        ctx.lineTo(roofRight - seg * 0.3, roofBaseY - seg * 0.4);
        // Bottom right
        ctx.lineTo(roofRight, roofBaseY);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle='rgba(0,0,0,0.7)'; ctx.lineWidth=1; ctx.stroke();
        
        // Silver border along the top edge
        ctx.strokeStyle='rgba(192,192,192,0.9)'; ctx.lineWidth=2.5;
        ctx.beginPath();
        ctx.moveTo(roofLeft + seg * 0.7, roofPeakY + seg * 0.3);
        ctx.lineTo(roofCenterX - seg * 0.4, roofPeakY);
        ctx.lineTo(roofCenterX + seg * 0.4, roofPeakY);
        ctx.lineTo(roofRight - seg * 0.7, roofPeakY + seg * 0.3);
        ctx.stroke();
        
        ctx.restore();
        return;
      }

      if(g.type==='silo'){
        // simple grain silo: cylindrical body with dome top and base shadow
        ctx.save();
        const bodyW = g.width, bodyH = g.height;
        const bx = g.x, by = g.y;
        // shadow on ground
        ctx.fillStyle='rgba(0,0,0,0.18)'; ctx.beginPath(); ctx.ellipse(bx+bodyW*0.5+sx, by+bodyH+6+sy, bodyW*0.6, bodyW*0.18, 0,0,Math.PI*2); ctx.fill();
        // body - white
        const baseColor = shadeColorRGB([255,255,255], t*0.08);
        ctx.fillStyle = baseColor; ctx.fillRect(bx, by, bodyW, bodyH);

        // ladder on the side (right side) - vertical rails + rungs - black
        const ladderX = Math.round(bx + bodyW*0.82);
        const railOffset = 4;
        ctx.strokeStyle = 'rgba(0,0,0,0.95)'; ctx.lineWidth = 2;
        // rails
        ctx.beginPath(); ctx.moveTo(ladderX-railOffset, by+8); ctx.lineTo(ladderX-railOffset, by+bodyH-8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ladderX+railOffset, by+8); ctx.lineTo(ladderX+railOffset, by+bodyH-8); ctx.stroke();
        // rungs
        ctx.lineWidth = 1.5;
        for(let ry = by+14; ry < by + bodyH - 10; ry += 12){ ctx.beginPath(); ctx.moveTo(ladderX-railOffset, ry); ctx.lineTo(ladderX+railOffset, ry); ctx.stroke(); }

        // half octagon roof - white
        ctx.fillStyle = shadeColorRGB([255,255,255], t*0.04);
        ctx.beginPath();
        const roofBaseY = by;
        const roofPeakY = by - 20;
        const roofLeft = bx;
        const roofRight = bx + bodyW;
        const roofCenterX = bx + bodyW / 2;
        const seg = bodyW / 4; // segment width for octagon sides
        
        // Start at bottom left
        ctx.moveTo(roofLeft, roofBaseY);
        // First angled side (bottom left to mid-left)
        ctx.lineTo(roofLeft + seg * 0.3, roofBaseY - seg * 0.4);
        // Second angled side (mid-left to upper-left)
        ctx.lineTo(roofLeft + seg * 0.7, roofPeakY + seg * 0.3);
        // Top left to peak
        ctx.lineTo(roofCenterX - seg * 0.4, roofPeakY);
        // Peak to top right
        ctx.lineTo(roofCenterX + seg * 0.4, roofPeakY);
        // Upper-right angled
        ctx.lineTo(roofRight - seg * 0.7, roofPeakY + seg * 0.3);
        // Mid-right angled
        ctx.lineTo(roofRight - seg * 0.3, roofBaseY - seg * 0.4);
        // Bottom right
        ctx.lineTo(roofRight, roofBaseY);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle='rgba(0,0,0,0.7)'; ctx.lineWidth=1; ctx.stroke();

        // bands
        ctx.strokeStyle='rgba(0,0,0,0.08)'; ctx.lineWidth=1; for(let y=by+12;y<by+bodyH-6;y+=12){ ctx.beginPath(); ctx.moveTo(bx+6,y); ctx.lineTo(bx+bodyW-6,y); ctx.stroke(); }
        // outline - black
        ctx.strokeStyle='rgba(0,0,0,1.0)'; ctx.lineWidth=2; ctx.strokeRect(bx, by, bodyW, bodyH);
        ctx.restore();
        return;
      }

      if(g.type==='water'){
        // municipal water tower: tall legs and a tank on top
        ctx.save();
        const wx = g.x, wy = g.y, ww = g.width, wh = g.height;
        // legs - black outline
        const legW = Math.max(3, Math.round(ww*0.12));
        const legH = Math.round(wh*0.7);
        ctx.strokeStyle='rgba(0,0,0,1.0)'; ctx.lineWidth=2;
        const lx1 = wx+ww*0.25, lx2 = wx+ww*0.75; const legTop = wy + (wh - legH);
        ctx.beginPath(); ctx.moveTo(lx1, wy+wh); ctx.lineTo(lx1 - 8, legTop); ctx.lineTo(lx1, legTop); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(lx2, wy+wh); ctx.lineTo(lx2 + 8, legTop); ctx.lineTo(lx2, legTop); ctx.stroke();
        // central support
        ctx.beginPath(); ctx.moveTo(wx+ww*0.5, wy+wh); ctx.lineTo(wx+ww*0.5, legTop+4); ctx.stroke();
        // tank - gray with half octagon roof
        const tankW = ww * 1.2; const tankH = Math.max(18, Math.round(wh*0.16));
        const tankX = Math.round(wx + (ww - tankW)/2);
        const roofHeight = 20;
        const tankY = legTop - tankH - roofHeight - 2;
        // gray gradient for tank
        const tankGrad = ctx.createLinearGradient(tankX, tankY, tankX, tankY + tankH + roofHeight);
        tankGrad.addColorStop(0, lerpColorStr([180,180,180],[160,160,160], t*0.2));
        tankGrad.addColorStop(0.4, lerpColorStr([150,150,150],[130,130,130], t*0.08));
        tankGrad.addColorStop(1, lerpColorStr([120,120,120],[100,100,100], t*0.02));
        ctx.fillStyle = tankGrad;
        
        // half octagon roof - gray
        ctx.beginPath();
        const roofBaseY = tankY + roofHeight;
        const roofPeakY = tankY;
        const roofLeft = tankX;
        const roofRight = tankX + tankW;
        const roofCenterX = tankX + tankW / 2;
        const seg = tankW / 4; // segment width for octagon sides
        
        // Start at bottom left
        ctx.moveTo(roofLeft, roofBaseY);
        // First angled side (bottom left to mid-left)
        ctx.lineTo(roofLeft + seg * 0.3, roofBaseY - seg * 0.4);
        // Second angled side (mid-left to upper-left)
        ctx.lineTo(roofLeft + seg * 0.7, roofPeakY + seg * 0.3);
        // Top left to peak
        ctx.lineTo(roofCenterX - seg * 0.4, roofPeakY);
        // Peak to top right
        ctx.lineTo(roofCenterX + seg * 0.4, roofPeakY);
        // Upper-right angled
        ctx.lineTo(roofRight - seg * 0.7, roofPeakY + seg * 0.3);
        // Mid-right angled
        ctx.lineTo(roofRight - seg * 0.3, roofBaseY - seg * 0.4);
        // Bottom right
        ctx.lineTo(roofRight, roofBaseY);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle='rgba(0,0,0,1.0)'; ctx.lineWidth=2; ctx.stroke();
        
        // body
        ctx.fillStyle = tankGrad;
        ctx.fillRect(tankX, roofBaseY, tankW, tankH);
        // bottom rim ellipse
        const bottomRimRadiusY = tankW * 0.18;
        ctx.beginPath(); 
        ctx.ellipse(tankX + tankW*0.5, roofBaseY + tankH, tankW*0.5, bottomRimRadiusY, 0, 0, Math.PI*2); 
        ctx.fill();
        // body outline - black
        ctx.strokeStyle='rgba(0,0,0,1.0)'; 
        ctx.lineWidth=2; 
        ctx.strokeRect(tankX, roofBaseY, tankW, tankH);
        ctx.restore();
        return;
      }

      if(g.type==='horse'){
        // Draw post and rail fence if this horse has one
        if(g.hasFence){
          const fenceLeft = g.x - 30;
          const fenceRight = g.x + g.width + 30;
          const fenceBottom = g.y + g.height + 5;
          const fenceHeight = 25;
          const fenceTop = fenceBottom - fenceHeight;
          
          // Posts
          ctx.fillStyle = '#654321';
          const postWidth = 4;
          const postCount = 5;
          const postSpacing = (fenceRight - fenceLeft) / (postCount - 1);
          for(let i=0; i<postCount; i++){
            const px = fenceLeft + i * postSpacing;
            ctx.fillRect(px - postWidth/2, fenceTop, postWidth, fenceHeight);
          }
          
          // Rails (2 horizontal)
          ctx.strokeStyle = '#654321';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(fenceLeft, fenceTop + fenceHeight * 0.3);
          ctx.lineTo(fenceRight, fenceTop + fenceHeight * 0.3);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(fenceLeft, fenceTop + fenceHeight * 0.7);
          ctx.lineTo(fenceRight, fenceTop + fenceHeight * 0.7);
          ctx.stroke();
        }
        
        const bob=Math.sin(frameCount*0.1 + g.phase)*1.5;
        const legPhase=(frameCount*0.2 + g.phase);
        const yBase=g.y + bob;
        
        // body - more oval/rounded
        ctx.fillStyle='#654321';
        ctx.beginPath();
        ctx.ellipse(g.x + g.width*0.5, yBase + g.height*0.55, g.width*0.48, g.height*0.35, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1; ctx.stroke();
        
        // neck - curved arc
        const neckX = g.x + g.width*0.2;
        const neckY = yBase + g.height*0.45;
        ctx.fillStyle='#5a4528';
        ctx.beginPath();
        ctx.ellipse(neckX, neckY, g.width*0.18, g.height*0.32, -0.3, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        
        // head - smaller ellipse
        const headX = neckX - g.width*0.08;
        const headY = neckY - g.height*0.25;
        ctx.fillStyle='#5a4528';
        ctx.beginPath();
        ctx.ellipse(headX, headY, g.width*0.15, g.height*0.18, -0.2, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        
        // ear - small triangle
        ctx.fillStyle='#4b3621';
        ctx.beginPath();
        ctx.moveTo(headX - g.width*0.05, headY - g.height*0.15);
        ctx.lineTo(headX, headY - g.height*0.22);
        ctx.lineTo(headX + g.width*0.05, headY - g.height*0.15);
        ctx.closePath();
        ctx.fill();
        
        // eye
        ctx.fillStyle='#000';
        ctx.beginPath();
        ctx.arc(headX + g.width*0.05, headY - g.height*0.05, 2, 0, Math.PI*2);
        ctx.fill();
        
        // mane - multiple curved strands
        ctx.strokeStyle='#3b2a1a'; ctx.lineWidth=2; ctx.lineCap='round';
        for(let i=0;i<3;i++){
          const manePhase = frameCount*0.25 + g.phase + i*0.5;
          const flick = 3 + 2*Math.sin(manePhase);
          const mx = neckX - g.width*0.05 + i*g.width*0.08;
          const my = neckY - g.height*0.15;
          ctx.beginPath();
          ctx.moveTo(mx, my);
          ctx.quadraticCurveTo(mx - g.width*0.08, my - flick, mx - g.width*0.12, my - flick*1.2);
          ctx.stroke();
        }
        
        // legs - with knees and hooves
        ctx.fillStyle='#5a4528';
        const legW = 4;
        for(let i=0;i<4;i++){
          const lx = g.x + g.width*(0.15 + 0.22*i);
          const legAnim = Math.sin(legPhase + i*Math.PI/2)*3;
          const topY = yBase + g.height*0.75;
          const kneeY = topY + g.height*0.15;
          const hoofY = yBase + g.height;
          
          // upper leg
          ctx.fillRect(lx + legAnim*0.5, topY, legW, g.height*0.15);
          // lower leg
          ctx.fillRect(lx + legAnim, kneeY, legW, g.height*0.1);
          // hoof
          ctx.fillStyle='#2a1810';
          ctx.fillRect(lx + legAnim - 1, hoofY - 3, legW + 2, 3);
          ctx.fillStyle='#5a4528';
          
          // dust effect
          if(frameCount%8===0 && Math.random()<0.3){
            dustParticles.push({x:lx+legAnim, y:hoofY, size:2+Math.random()*2, alpha:1, vy:-0.5-Math.random()});
          }
        }
        
        // tail - curved stroke
        const tailX = g.x + g.width*0.95;
        const tailY = yBase + g.height*0.5;
        const sway = Math.sin(frameCount*0.2 + g.phase)*(g.height*0.12);
        ctx.strokeStyle='#3b2a1a'; ctx.lineWidth=3; ctx.lineCap='round';
        ctx.beginPath();
        ctx.moveTo(tailX, tailY);
        ctx.quadraticCurveTo(tailX + g.width*0.15, tailY + sway*0.5, tailX + g.width*0.25, tailY + sway);
        ctx.stroke();
        
        return;
      }

      // default block (fallback)
      ctx.fillStyle='#8B4513'; ctx.fillRect(g.x,g.y,g.width,g.height);
    }

    function updateDust(speed){
      for(const p of dustParticles){ p.x-=speed; p.y+=p.vy; p.alpha-=0.02; }
      dustParticles=dustParticles.filter(p=>p.alpha>0);
      ctx.fillStyle='rgba(139,69,19,0.5)';
      for(const p of dustParticles){ ctx.globalAlpha=p.alpha; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
    }

    // === Plane ===
    function drawPlane(){
      if (!planeSpriteLoaded) return; // Ensure the sprite sheet is loaded

      // Calculate frame size from the loaded sprite sheet (2x2 grid)
      const spriteSize = planeSprite.width / 2; // Each frame is half the total width
      const displaySize = spriteSize * 0.15; // Make plane 15% of original size (50% larger than 10%)
      const frameIndex = Math.floor(frameCount / 33) % 4; // Cycle through 4 frames (70% slower)
      const sx = (frameIndex % 2) * spriteSize; // Source x in the sprite sheet
      const sy = Math.floor(frameIndex / 2) * spriteSize; // Source y in the sprite sheet

      ctx.save();
      ctx.translate(plane.x, plane.y);
      ctx.rotate(plane.angle); // Apply tilt/rotation from controls

      // Draw the current frame of the sprite sheet
      ctx.drawImage(planeSprite, sx, sy, spriteSize, spriteSize, -displaySize / 2, -displaySize / 2, displaySize, displaySize);

      ctx.restore();
    }

    function drawRings(){
      ctx.save();
      ctx.font='12px system-ui, sans-serif';
      ctx.fillStyle='#222';
      for(const r of rings){
        if(!r.collected){ r.glow=(r.glow+0.06)%1; const a=0.5+0.5*Math.sin(r.glow*Math.PI*2); ctx.strokeStyle=`rgba(255,255,0,${0.6+0.4*a})`; ctx.lineWidth=4+2*a; }
        else { ctx.strokeStyle='rgba(255,255,0,0.25)'; ctx.lineWidth=2; }
        ctx.beginPath(); ctx.arc(r.x,r.y,r.radius,0,Math.PI*2); ctx.stroke();
        if(!r.collected){ ctx.fillText(r.name, r.x-18, r.y-r.radius-6); }
      }
      ctx.restore();
    }

    function checkRingCollisions(){
      for(const r of rings){
        if(!r.collected){
          const dx = plane.x - r.x;
          const dy = plane.y - r.y;
          if(Math.hypot(dx,dy) < r.radius){
            r.collected = true;
            r.glow = 0;
            playChime();
          }
        }
      }
      // remove collected rings after a short delay / when offscreen
      rings = rings.filter(r => !(r.collected && (r.x < -r.radius)) );
    }

    function crashPlane(){
      if(!plane.alive) return;
      plane.alive = false;
      plane.crashed = true;
      plane.propAngle = 0;
      paused = true;
      try{ playChime(); }catch(e){}
      // spawn crash dust
      for(let i=0;i<20;i++){ dustParticles.push({x:plane.x + (Math.random()*80-40), y:plane.y + (Math.random()*40-20), size:2+Math.random()*4, alpha:1, vy:-1-Math.random()*2}); }

      // suspend audio if running
      try{ if(audioCtx && audioCtx.state==='running') audioCtx.suspend(); }catch(e){}

      // create overlay with restart button and use a snapshot of the canvas as background so the crash moment is frozen
      const existing = document.getElementById('crashOverlay');
      if(existing) existing.remove();
      const overlay = document.createElement('div');
      overlay.id = 'crashOverlay';
      overlay.style.position = 'fixed';
      overlay.style.left = '0';
      overlay.style.top = '0';
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.display = 'flex';
      overlay.style.alignItems = 'center';
      overlay.style.justifyContent = 'center';
      overlay.style.zIndex = '9999';
      // snapshot
      let snapshot = '';
      try{ snapshot = canvas.toDataURL(); }catch(e){}
      if(snapshot) overlay.style.background = `rgba(0,0,0,0.45) url('${snapshot}') center/contain no-repeat`;
      else overlay.style.background = 'rgba(0,0,0,0.45)';

      overlay.innerHTML = `
        <div style="background:rgba(255,255,255,0.96);padding:18px 24px;border-radius:12px;text-align:center;box-shadow:0 8px 30px rgba(0,0,0,0.4);">
          <div style="font-weight:800;margin-bottom:10px;color:#c00;font-size:20px;">CRASHED</div>
          <div style="margin-bottom:16px;color:#333">You collided â€” restart?</div>
          <button id="restartBtn" style="padding:8px 14px;border-radius:8px;border:0;background:#0078d4;color:#fff;cursor:pointer">Restart</button>
        </div>
      `;
      document.body.appendChild(overlay);
      const btn = document.getElementById('restartBtn');
      if(btn) btn.addEventListener('click', ()=>{ overlay.remove(); try{ if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); }catch(e){} restartGame(); });
    }

    // === World step ===
    function worldStep(speed){
      drawSky();

      // Looping with A/D: when A or D is held (exclusively), enter loop mode
      const wantLoopA = !!keys['a'] && !keys['d'];
      const wantLoopD = !!keys['d'] && !keys['a'];
      if (wantLoopA || wantLoopD) {
        const dir = wantLoopA ? -1 : 1;
        if (!plane.loop) {
          plane.loop = true;
          plane.loopDir = dir;
          plane.loopCenterY = plane.y; // center the loop where the plane currently is
          plane.loopProgress = 0;
        } else {
          plane.loopDir = dir;
        }
      } else {
        // stop looping when neither A nor D is held
        if (plane.loop) {
          plane.loop = false;
          plane.loopProgress = 0;
        }
      }

      if (plane.loop) {
        // perform circular loop motion: update progress, set angle and y along a circle
          plane.loopProgress += plane.loopDir * plane.loopSpeed;
        // keep progress in reasonable range to avoid overflow
        if (plane.loopProgress > Math.PI*2) plane.loopProgress -= Math.PI*2;
        if (plane.loopProgress < -Math.PI*2) plane.loopProgress += Math.PI*2;
        // angle follows progress so the plane rotates as it loops
        plane.angle = plane.loopProgress;
        // vertical motion along sine gives the loop effect; radius controls loop size
        plane.y = plane.loopCenterY + Math.sin(plane.loopProgress) * plane.loopRadius;
        // ensure loop keeps plane on screen vertically
        plane.y = Math.max(10, Math.min(h()-10, plane.y));
      } else {
        // W/S control: climb/dive (steering)
        let targetAngle = 0;
        if (keys['w']) targetAngle = -0.35; // climb (tilt up)
        else if (keys['s']) targetAngle = 0.35; // dive (tilt down)
        // smooth interpolation back to center when released
        plane.angle += (targetAngle - plane.angle) * 0.08;

        // clamp vertically so the plane stays on screen
        plane.y = Math.max(10, Math.min(h()-10, plane.y));
      }

      // keep the plane at a fixed on-screen X (camera); move world according to heading
      plane.x = CAMERA_X;

      // movement: compute heading velocity (based on current angle)
      const headingSpeedFactor = 0.6;
      const vx = Math.cos(plane.angle) * speed * headingSpeedFactor;
      // vy is already applied to plane.y when not looping; we don't need vy here for world scroll

      // world scroll should match plane's intended horizontal movement: increase scroll when plane points right
      const worldShift = speed + vx;

      // audio pitch modulation: alter engine oscillator frequency by speed and plane angle
      if(audioInited && engineOsc){
        try{
          const current = engineOsc.frequency.value || engineBaseFreq;
          const target = engineBaseFreq + speed * speedFreqFactor + plane.angle * angleFreqFactor;
          const clamped = Math.max(minEngineFreq, Math.min(maxEngineFreq, target));
          engineOsc.frequency.value = current + (clamped - current) * freqSmoothing;
        }catch(e){/* ignore if audio not ready */}
      }

      // progress & spawns
      distCloud+=speed; distGround+=speed; distRing+=speed;
      if(distCloud>=DIST_CLOUD){ spawnClouds(); distCloud=0; }
      if(distGround>=DIST_GROUND){ spawnGroundElements(); distGround=0; }
      if(distRing>=DIST_RING){ spawnRing(); distRing=0; }

      // scroll world (Shift only affects horizontal, not vertical)
      for(const c of clouds) c.x -= worldShift*0.6;
      for(const g of groundElements) g.x -= worldShift;
      for(const r of rings) r.x -= worldShift;
      for(const b of bullets) b.x += (b.speed - worldShift);

      // update interactive door state for barns (open when plane approaches)
      for(const g of groundElements){
        if(g.type==='barn'){
          const doorCenterY = g.y + g.height*0.8;
          const approach = (plane.x + 140 > g.x && plane.x < g.x + g.width + 40 && Math.abs(plane.y - doorCenterY) < g.height*0.6);
          g.doorTarget = approach ? 1 : 0;
          g.doorProgress = (g.doorProgress || 0) + (g.doorTarget - (g.doorProgress || 0)) * 0.14;
          // clamp
          g.doorProgress = Math.max(0, Math.min(1, g.doorProgress));
        }
      }

      // cull
      clouds=clouds.filter(c=>c.x>-c.size);
      groundElements=groundElements.filter(g=>g.x>-g.width);
      rings=rings.filter(r=>r.x>-r.radius || !r.collected);
      bullets=bullets.filter(b=>b.x < w()+40);

      // draw
      clouds.forEach(drawCloud);
      groundElements.forEach(drawGroundElement);
      updateDust(speed);
      drawRings();
      // bullets
      drawBullets();
      drawPlane();

      // plane collision checks (only when alive) -- run after drawing so snapshot captures crash moment
      if(plane.alive){
        // ground collision: if plane hits the ground surface
        const groundTop = h() - 60;
        const planeHalfH = 15;
        if(plane.y + planeHalfH >= groundTop){ crashPlane(); }

        // bounding-box collision with ground elements/buildings
        const px = plane.x - 30; const py = plane.y - 15; const pw = 60; const ph = 30;
        for(const g of groundElements){
          const gx = g.x, gy = g.y, gw = g.width, gh = g.height;
          if(px < gx + gw && px + pw > gx && py < gy + gh && py + ph > gy){
            // if it's a barn, allow passage through the door when fully open and plane is inside the door area
            if(g.type==='barn'){
              const doorTotalW = Math.max(50, Math.floor(g.width * 0.5));
              const closedDoorX = Math.round(g.x + (g.width - doorTotalW) / 2);
              const doorY = g.y + g.height * 0.5;
              const doorH = Math.max(40, Math.floor(g.height * 0.5));
              const openOffset = Math.round((doorTotalW + 8) * (g.doorProgress || 0));
              const apertureLeft = closedDoorX;
              const apertureRight = closedDoorX + openOffset;
              const apertureW = openOffset;
              // allow passage if door is sufficiently open AND plane center X is within the aperture AND plane overlaps door vertically
              const doorOpen = (g.doorProgress || 0) > 0.3; // door must be at least 30% open
              const planeCenterX = plane.x;
              const planeCenterY = plane.y;
              const planeXInAperture = (planeCenterX > apertureLeft) && (planeCenterX < apertureRight);
              const planeYInDoor = (planeCenterY > doorY - 20) && (planeCenterY < doorY + doorH + 20);
              if(doorOpen && planeXInAperture && planeYInDoor){
                continue; // plane is centered in the aperture â€” allow passage
              }
            }
            crashPlane(); break;
          }
        }
      }

      // ring collect
      checkRingCollisions();
    }

    function update(ts){
      if(lastTime===null) lastTime = ts;
      const dt = (ts - lastTime)/1000; // seconds since last frame
      lastTime = ts;
      frameCount++;
      // advance sun based on real elapsed time for a smooth day/night cycle
      sunlightAngle += (2*Math.PI / dayDuration) * dt;
      const speed=currentScrollSpeed();
      worldStep(speed);
      if(!paused) requestAnimationFrame(update);
    }

    // seed: a few clouds & a visible farmhouse
    function seedDemo(){
      groundElements.length=0; clouds.length=0; rings.length=0; dustParticles.length=0; bullets.length=0;
      const bw=120,bh=100;
      groundElements.push({x:Math.max(40,Math.min(200,w()-bw-40)), y:h()-60-bh, width:bw, height:bh, type:'farmhouse'});
      for(let i=0;i<3;i++){ clouds.push({x:80+i*140, y:40+i*20, size:30+10*i}); }
    }
    // start demo and starfield
    seedDemo();
    generateStars(120);

    // === Audio ===
    let audioCtx=null, engineOsc=null, engineGain=null, lfoOsc=null, lfoGain=null; let audioInited=false; let muted=false;
    // engine pitch tuning
    // make the engine much lower and less warbly
    const engineBaseFreq = 70; // lower base tone (was 140)
    // previously scaled to 0.25 sensitivity; now reduce that sensitivity by 25% (i.e. *0.75)
    // resulting factors: speed: 40 * 0.25 * 0.75 = 7.5 ; angle: 60 * 0.25 * 0.75 = 11.25
    const speedFreqFactor = 7.5; // Hz per scroll-speed unit (reduced by 25%)
    const angleFreqFactor = 11.25; // Hz per radian of tilt (reduced by 25%)
    const freqSmoothing = 0.08;
    const minEngineFreq = 80;
    const maxEngineFreq = 800;
    const muteBtn=document.getElementById('mute');
    function initAudio(){
      if(audioInited) return; audioInited=true;
      audioCtx=new (window.AudioContext||window.webkitAudioContext)();
      // engine hum: sawtooth ~140Hz with gentle tremolo
      engineOsc=audioCtx.createOscillator(); engineOsc.type='sawtooth'; engineOsc.frequency.value=engineBaseFreq;
      engineGain=audioCtx.createGain(); engineGain.gain.value=0.03; // base volume (slightly lower)
      lfoOsc=audioCtx.createOscillator(); lfoOsc.type='sine'; lfoOsc.frequency.value=1.2; // slower oscillation (less warble)
      lfoGain=audioCtx.createGain(); lfoGain.gain.value=0.005; // shallower tremolo depth
      lfoOsc.connect(lfoGain); lfoGain.connect(engineGain.gain);
      engineOsc.connect(engineGain).connect(audioCtx.destination);
      engineOsc.start(); lfoOsc.start();
    }
    function setMuted(m){
      muted=m; muteBtn.textContent = muted ? 'ðŸ”‡' : 'ðŸ”Š';
      if(!audioCtx) return;
      if(muted && audioCtx.state==='running') audioCtx.suspend();
      else if(!muted && audioCtx.state==='suspended') audioCtx.resume();
    }
    muteBtn.addEventListener('click',()=>{ if(!audioInited) initAudio(); setMuted(!muted); });

    function quickBeep(freq=880, dur=0.12, vol=0.08){ if(!audioCtx||muted||audioCtx.state!=='running') return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sine'; o.frequency.value=freq; g.gain.value=vol; o.connect(g).connect(audioCtx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+dur); o.stop(audioCtx.currentTime+dur); }
    function playChime(){ quickBeep(1200,0.15,0.1); }
    function playPop(){ quickBeep(220,0.08,0.08); }

    function restartGame(){
      // clear world
      groundElements.length=0; clouds.length=0; rings.length=0; dustParticles.length=0; bullets.length=0;
      // reset plane
      plane.alive = true; plane.crashed = false; plane.angle = 0; plane.propAngle = 0; plane.loopActive = false; plane.loopProgress = 0;
      plane.y = h()/2;
      paused = false;
      // reseed a simple scene
      seedDemo();
      generateStars(120);
      // resume loop
      lastTime = null;
      requestAnimationFrame(update);
    }

    // === Bullets ===
    function fireBullet(){ bullets.push({x:plane.x+40, y:plane.y, speed:6}); playPop(); }
    function drawBullets(){ ctx.fillStyle='yellow'; for(const b of bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,2.5,0,Math.PI*2); ctx.fill(); } }

    // Load the sprite sheet for the plane
const planeSprite = new Image();
let planeSpriteLoaded = false;
planeSprite.onload = () => {
  console.log('Plane sprite sheet loaded successfully');
  planeSpriteLoaded = true;
};
planeSprite.onerror = () => {
  console.error('Failed to load the plane sprite sheet. Please check the file path.');
};
planeSprite.src = 'plane2x2.png';

    requestAnimationFrame(update);
  </script>
</body>
</html>
