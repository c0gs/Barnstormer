<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Barnstormer â€“ Rings + Horses (dust) + Radio Towers + Dynamic Lighting + Lanes + Audio</title>
  <style>
    html,body{height:100%;margin:0;background:#87CEEB;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    canvas{display:block;margin:0 auto;image-rendering:crisp-edges;image-rendering:-webkit-optimize-contrast;}
    #hud{position:fixed;left:10px;top:10px;color:#111;background:rgba(255,255,255,.6);padding:6px 10px;border-radius:8px;font-weight:600}
  </style>
</head>
<body>
  <div id="hud">W/S or A/D: up/down â€¢ Shift: speed boost â€¢ Space: fire
    <button id="mute" style="margin-left:8px;border:0;background:#fff;border-radius:6px;padding:4px 8px;cursor:pointer">ðŸ”Š</button>
  </div>
  <canvas id="game"></canvas>
  <script type="module">
    const canvas=document.getElementById('game');
    const ctx=canvas.getContext('2d');
    function resize(){
      const dpr=Math.max(2,window.devicePixelRatio||1);
      canvas.width=innerWidth*dpr;
      canvas.height=innerHeight*dpr;
      canvas.style.width=innerWidth+'px';
      canvas.style.height=innerHeight+'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    resize();
    addEventListener('resize',resize);

    // === State ===
    const w=()=>canvas.clientWidth, h=()=>canvas.clientHeight;
    const CAMERA_X = 150; // fixed on-screen x for the plane (camera follows world)
    const plane={x:CAMERA_X,y:h()/2,baseSpeed:1.2,boostSpeed:3,propAngle:0,angle:0,
      // looping state: some legacy fields kept for compatibility
      loop:false, loopProgress:0, loopDir:0, loopCenterY:h()/2, loopRadius:80, loopSpeed:0.02,
      // crash state
      alive:true, crashed:false
    };
    let paused = false;
    let rings=[],groundElements=[],clouds=[],dustParticles=[],bullets=[];
    const DIST_RING=420,DIST_GROUND=520,DIST_CLOUD=220;
    let distRing=0,distGround=0,distCloud=0;
    let frameCount=0;

    const keys={};
    addEventListener('keydown',e=>{ const k=e.key.toLowerCase(); keys[k]=true; if(!audioInited) initAudio(); if(k===' '||k==='space'){ fireBullet(); e.preventDefault(); }});
    addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });

    function currentScrollSpeed(){return keys['shift']?plane.boostSpeed:plane.baseSpeed;}

    // === Lighting helpers (dynamic sky & ground) ===
    let sunlightAngle=0; // drives time-of-day and shadow direction
    let stars = [];
    const clamp01=x=>Math.max(0,Math.min(1,x));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const lerpColor=(c1,c2,t)=>{
      t=clamp01(t);
      const r=Math.round(lerp(c1[0],c2[0],t));
      const g=Math.round(lerp(c1[1],c2[1],t));
      const b=Math.round(lerp(c1[2],c2[2],t));
      return `rgb(${r},${g},${b})`;
    };
    const dayToDuskT=()=>clamp01((Math.sin(sunlightAngle- Math.PI/2)+1)/2); // 0 midday -> 1 dusk
    const sunPhase=()=>clamp01((Math.sin(sunlightAngle)+1)/2); // 0 night -> 1 day

    function generateStars(count){
      stars = [];
      for(let i=0;i<count;i++){
        stars.push({ x: Math.random()*w(), y: Math.random()*h()*0.55, size: Math.random()*1.8+0.2, alpha: Math.random()*0.9 });
      }
    }
    let lastTime = null;
    const dayDuration = 60; // seconds for a full day/night cycle

    function drawSky(){
      const t=dayToDuskT();
      const sun = sunPhase();
      const top = lerpColor([135,206,235],[20,20,48], 1 - sun); // blue day -> dark night
      const bot = lerpColor([176,224,255],[10,10,30], 1 - sun);
      const g=ctx.createLinearGradient(0,0,0,h());
      g.addColorStop(0,top); g.addColorStop(1,bot);
      ctx.fillStyle=g; ctx.fillRect(0,0,w(),h());

      // sun during day (soft glow) and stars/moon at night
      const nightFactor = 1 - sun;
      // sun path: move the sun along an arc across the sky using sunlightAngle
      if(sun > 0.05){
        const sunArcX = w()*0.5 + Math.cos(sunlightAngle - Math.PI/2) * (w()*0.38);
        const sunArcY = h()*0.22 + Math.sin(sunlightAngle - Math.PI/2) * (h()*0.16);
        // radial glow
        const rg = ctx.createRadialGradient(sunArcX, sunArcY, 6, sunArcX, sunArcY, 120);
        rg.addColorStop(0, 'rgba(255,250,200,0.95)'); rg.addColorStop(0.2, 'rgba(255,235,120,0.6)'); rg.addColorStop(0.6, 'rgba(255,200,80,0.12)'); rg.addColorStop(1, 'rgba(255,200,80,0)');
        ctx.fillStyle = rg; ctx.beginPath(); ctx.arc(sunArcX, sunArcY, 120, 0, Math.PI*2); ctx.fill();
        // core
        ctx.fillStyle = 'rgba(255,245,180,1)'; ctx.beginPath(); ctx.arc(sunArcX, sunArcY, 22, 0, Math.PI*2); ctx.fill();
      }

      if(nightFactor > 0.05){
        ctx.save();
        ctx.globalAlpha = Math.min(0.9, nightFactor*1.2);
        for(const s of stars){ ctx.fillStyle = `rgba(255,255,255,${s.alpha*nightFactor})`; ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill(); }
        // moon (opposite the sun)
        const moonX = w()*0.5 - Math.cos(sunlightAngle - Math.PI/2) * (w()*0.38);
        const moonY = h()*0.22 - Math.sin(sunlightAngle - Math.PI/2) * (h()*0.16);
        const moonRadius = 28;
        ctx.fillStyle = `rgba(255,245,220,${0.6*nightFactor})`;
        ctx.beginPath(); ctx.arc(moonX, moonY, moonRadius, 0, Math.PI*2); ctx.fill();
        
        // craters on moon
        ctx.fillStyle = `rgba(180,180,200,${0.4*nightFactor})`;
        // larger craters
        ctx.beginPath(); ctx.arc(moonX - 8, moonY - 10, 5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(moonX + 12, moonY - 5, 4, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(moonX + 5, moonY + 12, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(moonX - 15, moonY + 8, 3, 0, Math.PI*2); ctx.fill();
        // smaller craters for detail
        ctx.fillStyle = `rgba(160,160,180,${0.3*nightFactor})`;
        ctx.beginPath(); ctx.arc(moonX + 8, moonY + 2, 2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(moonX - 10, moonY - 2, 1.8, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(moonX + 14, moonY + 10, 2.2, 0, Math.PI*2); ctx.fill();
        
        ctx.restore();
      }

      const groundColor=lerpColor([34,139,34],[12,40,12], 1 - sun);
      ctx.fillStyle=groundColor; ctx.fillRect(0,h()-60,w(),60);
    }

    // === Spawners ===
    function spawnClouds(){
      const num=Math.floor(Math.random()*3)+1;
      for(let i=0;i<num;i++){
        const size=24+Math.random()*56;
        clouds.push({x:w()+80+Math.random()*160,y:20+Math.random()*(h()*0.5-40),size});
      }
    }

    function spawnGroundElements(){
      // choose 1-3 elements, non-overlapping, extra spacing rules (barn-tree, horses)
      const count=Math.floor(Math.random()*3)+1;
      for(let i=0;i<count;i++){
        // type distribution including radio, silo, water and horse
        const r=Math.random();
        let type=(r<0.14)?'farmhouse':(r<0.28)?'office':(r<0.42)?'barn':(r<0.56)?'tree':(r<0.70)?'radio':(r<0.80)?'silo':(r<0.88)?'water':'horse';
        // sizes â€” choose ranges appropriate to the element type
        // Height hierarchy: horses < trees < farmhouse < barn < silo < water tower, office < radio tower
        let baseW, baseH;
        if(type === 'tree'){
          // trees: taller than horses, shorter than farmhouse
          baseW = 18 + Math.random()*20; // 18..38
          baseH = 50 + Math.random()*80; // 50..130
        } else if(type === 'radio'){
          // radio towers: tallest
          baseW = 10 + Math.random()*10; // 10..20 (thinner)
          baseH = 220 + Math.random()*160; // 220..380
        } else if(type === 'horse'){
          // horses: smallest, low-profile objects
          baseW = 28 + Math.random()*24; // 28..52
          baseH = 14 + Math.random()*14; // 14..28
        } else if(type === 'office'){
          // office buildings: taller than silo, comparable to water tower
          baseW = 80 + Math.random()*100; // 80..180
          baseH = 180 + Math.random()*140; // 180..320
        } else if(type === 'barn'){
          // barns: taller than farmhouse, shorter than silo
          baseW = 100 + Math.random()*100; // 100..200
          baseH = 120 + Math.random()*90; // 120..210
        } else if(type === 'farmhouse'){
          // farmhouse: taller than trees, shorter than barn
          baseW = 60 + Math.random()*70; // 60..130
          baseH = 80 + Math.random()*80; // 80..160
        } else if(type === 'silo'){
          // silo: taller than barn, shorter than water tower
          baseW = 40 + Math.random()*50; // 40..90
          baseH = 150 + Math.random()*110; // 150..260
        } else if(type === 'water'){
          // water tower: taller than silo, thinner profile
          baseW = 35 + Math.random()*35; // 35..70
          baseH = 160 + Math.random()*140; // 160..300
        } else {
          // fallback block
          baseW = 50 + Math.random()*40;
          baseH = 50 + Math.random()*50;
        }
            let newX = w()+100+Math.random()*200;
            const pad=20, extraBarnTree=100, extraHorseGap=60;
            const groundY=h()-60-baseH;
            // If a generated position overlaps existing ground elements, shift it right until it fits.
            // Use a safety cap to avoid infinite loops.
            let safety = 0;
            while(true){
              const overlap = groundElements.find(g=>{
                const centerA = g.x + g.width/2;
                const centerB = newX + baseW/2;
                    const barnTreeGap = ((g.type==='barn'&&type==='tree')||(g.type==='tree'&&type==='barn')) ? extraBarnTree : 0;
                    const horseAvoid = ((g.type==='horse'&&type!=='horse')||(type==='horse'&&g.type!=='horse')) ? extraHorseGap : 0;
                    const siloAvoid = ((g.type==='silo'&&type!=='silo')||(type==='silo'&&g.type!=='silo')) ? 80 : 0;
                    const waterAvoid = ((g.type==='water'&&type!=='water')||(type==='water'&&g.type!=='water')) ? 100 : 0;
                const minGap = (g.width/2 + baseW/2 + pad + barnTreeGap + horseAvoid);
                return Math.abs(centerA - centerB) < minGap;
              });
              if(!overlap) break;
              // Move newX to just beyond the overlapping element's edge
              const barnTreeGap = ((overlap.type==='barn'&&type==='tree')||(overlap.type==='tree'&&type==='barn')) ? extraBarnTree : 0;
              const horseAvoid = ((overlap.type==='horse'&&type!=='horse')||(type==='horse'&&overlap.type!=='horse')) ? extraHorseGap : 0;
              const siloAvoid = ((overlap.type==='silo'&&type!=='silo')||(type==='silo'&&overlap.type!=='silo')) ? 80 : 0;
              const waterAvoid = ((overlap.type==='water'&&type!=='water')||(type==='water'&&overlap.type!=='water')) ? 100 : 0;
              const minGap = (overlap.width/2 + baseW/2 + pad + barnTreeGap + horseAvoid + siloAvoid + waterAvoid);
              newX = overlap.x + overlap.width/2 + baseW/2 + pad + barnTreeGap + horseAvoid + 10;
              safety++;
              if(safety>50){
                // fallback: place further to the right
                newX += 200 + Math.random()*200;
                break;
              }
            }
        const phase=(type==='horse')?Math.random()*Math.PI*2:0;
        const elem = {x:newX,y:groundY,width:baseW,height:baseH,type,phase};
        if(type==='barn'){ elem.doorProgress = 0; elem.doorTarget = 0; }
        if(type==='tree'){
          // per-tree shape params to get variation while drawing
          elem.trunkWidth = Math.max(3, Math.round(baseW * (0.12 + Math.random()*0.12))); // small trunk
          elem.canopyCount = 2 + Math.floor(Math.random()*3); // 2..4 clumps
          elem.canopyR = Math.max(12, Math.round(baseW * (0.9 + Math.random()*0.6))); // radius for canopy clumps
          elem.canopyYOffset = Math.round(baseH * (0.18 + Math.random()*0.18));
          elem.canopySpread = Math.round(baseW * (0.4 + Math.random()*0.8));
          elem.leafHueShift = (Math.random()*0.2 - 0.1); // small color variation
          elem.variantSeed = Math.random();
        }
        groundElements.push(elem);
      }
    }

    // Rings: 5 vertical levels within the top 3/5 of the screen
    const ringLevels=()=>{
      const top=h()*0.1; // leave headroom
      const step=(h()*0.6 - top)/4; // top 60%
      return [0,1,2,3,4].map(i=>top + i*step);
    };
    function spawnRing(){
      const levels=ringLevels();
      const i = Math.floor(Math.random()*levels.length);
      const y = levels[i];
      const laneName = `Ring ${i+1}`; // 1..5 top->bottom
      const ringRadius = 30;
      const ringX = w() + 80;
      
      // check if ring would collide with any building
      let collides = false;
      for(const g of groundElements){
        const dx = ringX - (g.x + g.width/2);
        const dy = y - (g.y + g.height/2);
        const dist = Math.hypot(dx, dy);
        const minDist = ringRadius + Math.max(g.width, g.height)/2 + 20; // buffer zone
        if(dist < minDist){
          collides = true;
          break;
        }
      }
      
      // only spawn if no collision
      if(!collides){
        rings.push({x:ringX,y,radius:ringRadius,glow:0,collected:false,lane:i+1,name:laneName});
      }
    }

    // === Drawing helpers ===
    function drawCloud(c){
      const t=dayToDuskT();
      ctx.fillStyle=lerpColor([255,255,255],[255,230,210],t);
      ctx.beginPath(); ctx.ellipse(c.x,c.y,c.size,c.size*0.6,0,0,Math.PI*2); ctx.fill();
    }

    function shadeColorRGB(rgb, amt){
      const k=1-amt; return `rgb(${Math.round(rgb[0]*k)},${Math.round(rgb[1]*k)},${Math.round(rgb[2]*k)})`;
    }

    function drawGroundElement(g){
      const t=dayToDuskT();
      const shadowLen=lerp(3,12,t);
      const sx=Math.cos(sunlightAngle)*shadowLen;
      const sy=Math.sin(sunlightAngle)*shadowLen;

      if(g.type==='farmhouse'){
        // body
        ctx.save();
        const wall=[222,184,135];
        ctx.shadowColor='rgba(0,0,0,0.35)'; ctx.shadowBlur=5; ctx.shadowOffsetX=sx; ctx.shadowOffsetY=sy;
        ctx.fillStyle=shadeColorRGB(wall, t*0.25); ctx.fillRect(g.x,g.y,g.width,g.height);
        ctx.shadowColor='transparent';
        // outline
        ctx.strokeStyle='rgba(0,0,0,0.85)'; ctx.lineWidth=1; ctx.strokeRect(g.x,g.y,g.width,g.height);
        // door
        const dW=g.width*0.2,dH=g.height*0.4,dX=g.x+g.width*0.4,dY=g.y+g.height*0.6;
        ctx.fillStyle=shadeColorRGB([139,69,19],t*0.3); ctx.fillRect(dX,dY,dW,dH);
        ctx.strokeRect(dX,dY,dW,dH);
        // windows with dynamic reflection and night glow
        const winW=g.width*0.2,winH=g.height*0.25;
        const windows=[{x:g.x+g.width*0.1,y:g.y+g.height*0.25},{x:g.x+g.width*0.7,y:g.y+g.height*0.25}];
        windows.forEach(wi=>{
          // window color transitions from blue (day) to warm yellow (night)
          const nightGlow = t > 0.5 ? (t - 0.5) * 2 : 0; // glow factor for night
          const dayColor = 'rgba(255,255,255,0.85)';
          const nightColor = `rgba(255,240,150,${0.7 + nightGlow * 0.3})`; // warmer and brighter at night
          const blendColor = t < 0.5 ? dayColor : nightColor;
          
          const grad=ctx.createLinearGradient(wi.x,wi.y,wi.x,wi.y+winH);
          grad.addColorStop(0, blendColor);
          grad.addColorStop(0.4, t < 0.5 ? '#b0e0ff' : `rgba(255,220,100,${0.8 + nightGlow * 0.2})`);
          grad.addColorStop(1, t < 0.5 ? '#87ceeb' : `rgba(255,210,80,${0.6 + nightGlow * 0.2})`);
          ctx.fillStyle=grad; ctx.fillRect(wi.x,wi.y,winW,winH);
          
          // glow effect at night
          if(nightGlow > 0){
            ctx.shadowColor = `rgba(255,200,100,${nightGlow * 0.4})`;
            ctx.shadowBlur = 8 * nightGlow;
          }
          ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1; ctx.strokeRect(wi.x,wi.y,winW,winH);
          ctx.shadowColor = 'transparent';
          
          // specular highlight
          ctx.fillStyle='rgba(255,255,255,0.18)'; ctx.fillRect(wi.x+winW*0.12, wi.y+winH*0.08, winW*0.5, winH*0.18);
        });
        // roof
        ctx.fillStyle=shadeColorRGB([165,42,42],t*0.25);
        ctx.beginPath(); ctx.moveTo(g.x,g.y); ctx.lineTo(g.x+g.width/2,g.y-18); ctx.lineTo(g.x+g.width,g.y); ctx.closePath(); ctx.fill();
        ctx.strokeStyle='rgba(0,0,0,0.65)'; ctx.lineWidth=1; ctx.stroke();
        ctx.restore();
        return;
      }

      if(g.type==='office'){
        ctx.save();
        ctx.shadowColor='rgba(0,0,0,0.35)'; ctx.shadowBlur=5; ctx.shadowOffsetX=sx; ctx.shadowOffsetY=sy;
        ctx.fillStyle=shadeColorRGB([150,150,150], t*0.3); ctx.fillRect(g.x,g.y,g.width,g.height);
        ctx.shadowColor='transparent';
        // outline building
        ctx.strokeStyle='rgba(0,0,0,0.85)'; ctx.lineWidth=1; ctx.strokeRect(g.x,g.y,g.width,g.height);
        // draw window grid
        const cols = Math.max(2, Math.floor(g.width / 14));
        const rows = Math.max(2, Math.floor(g.height / 16));
        const winW = Math.min(12, Math.max(6, Math.floor((g.width - (cols+1)*4) / cols)));
        const winH = Math.min(10, Math.max(6, Math.floor((g.height - (rows+1)*3) / rows)));
        const gapX = (g.width - cols*winW) / (cols+1);
        const gapY = (g.height - rows*winH) / (rows+1);
        for(let ry=0; ry<rows; ry++){
          for(let cx=0; cx<cols; cx++){
            const wx = Math.round(g.x + gapX + cx*(winW+gapX));
            const wy = Math.round(g.y + gapY + ry*(winH+gapY));
            // windows get warmer and brighter toward dusk/night
            const nightGlow = t > 0.5 ? (t - 0.5) * 2 : 0; // glow intensity for night
            const winColor = lerpColor([40,45,55],[255,240,150], t);
            const winAlpha = 0.9 + nightGlow * 0.2; // brighter at night
            // reflective vertical gradient: bright at top to window color
            const wg = ctx.createLinearGradient(wx, wy, wx, wy+winH);
            wg.addColorStop(0, t < 0.5 ? 'rgba(255,255,255,0.9)' : `rgba(255,255,200,${winAlpha})`);
            wg.addColorStop(0.18, `rgba(${winColor[0]},${winColor[1]},${winColor[2]},${winAlpha})`);
            wg.addColorStop(1, lerpColor([20,25,30],[220,180,100], t));
            ctx.fillStyle = wg;
            ctx.fillRect(wx, wy, winW, winH);
            
            // glow effect at night
            if(nightGlow > 0){
              ctx.shadowColor = `rgba(255,200,100,${nightGlow * 0.3})`;
              ctx.shadowBlur = 6 * nightGlow;
              ctx.strokeStyle = `rgba(0,0,0,0.5)`; ctx.lineWidth=1; ctx.strokeRect(wx, wy, winW, winH);
              ctx.shadowColor = 'transparent';
            } else {
              ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth=1; ctx.strokeRect(wx, wy, winW, winH);
            }
            
            // subtle specular highlight (top-left)
            ctx.fillStyle = 'rgba(255,255,255,0.16)';
            ctx.fillRect(wx + Math.round(winW*0.12), wy + Math.round(winH*0.08), Math.round(winW*0.45), Math.round(winH*0.16));
          }
        }
        ctx.restore();
        return;
      }

      if(g.type==='tree'){
        ctx.save();
        // ground shadow ellipse
        ctx.fillStyle='rgba(0,0,0,0.22)';
        ctx.beginPath(); ctx.ellipse(g.x+g.width*0.5+sx, g.y+g.height+4+sy, g.width*0.7, g.width*0.22, 0,0,Math.PI*2); ctx.fill();
        // trunk
        ctx.fillStyle=shadeColorRGB([101,67,33], t*0.25);
        const tw = g.trunkWidth || Math.max(3, Math.round(g.width*0.18));
        const trunkX = Math.round(g.x + (g.width - tw)/2);
        const trunkY = Math.round(g.y + g.height*0.35);
        const trunkH = Math.round(g.height*0.65);
        ctx.fillRect(trunkX, trunkY, tw, trunkH);
        ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1; ctx.strokeRect(trunkX, trunkY, tw, trunkH);
        // canopy: multiple clumps using per-tree params
        const leafBase = lerpColor([46,139,87],[20,70,40],t);
        for(let i=0;i<(g.canopyCount||3);i++){
          const seed = (g.variantSeed||0.5) * 10 + i*1.37;
          const cx = Math.round(g.x + g.width*0.5 + (i - ((g.canopyCount||3)-1)/2) * (g.canopySpread || (g.width*0.6)) / (g.canopyCount||3));
          const cy = Math.round(g.y + (g.canopyYOffset || g.height*0.25) - i*6);
          const r = Math.round((g.canopyR || Math.max(12, g.width*0.6)) * (0.8 + 0.35 * Math.sin(seed)));
          const lcT = clamp01(t + (g.leafHueShift || 0));
          const leafColor = lerpColor([46,139,87],[20,70,40], lcT);
          ctx.fillStyle = leafColor;
          ctx.beginPath(); ctx.ellipse(cx, cy, r, Math.round(r*0.8), 0, 0, Math.PI*2); ctx.fill();
        }
        // outline canopy rough
        ctx.strokeStyle='rgba(0,0,0,0.45)'; ctx.lineWidth=1;
        const outlineCx = g.x+g.width*0.5, outlineCy = g.y+g.height*0.25, outlineR = Math.max(g.width,g.height*0.45)*0.55;
        ctx.beginPath(); ctx.ellipse(outlineCx, outlineCy, outlineR, outlineR*0.78, 0, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
        return;
      }

      if(g.type==='radio'){
        const baseX=g.x+g.width/2, topY=g.y, botY=g.y+g.height;
        ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(baseX-g.width/2,botY); ctx.lineTo(baseX-g.width*0.2,topY);
        ctx.moveTo(baseX+g.width/2,botY); ctx.lineTo(baseX+g.width*0.2,topY);
        for(let y=0;y<g.height;y+=12){ const yPos=botY-y; const t=(y/g.height); const half=lerp(g.width/2,g.width*0.2,t); ctx.moveTo(baseX-half,yPos); ctx.lineTo(baseX+half,yPos-6); }
        ctx.stroke();
        ctx.fillStyle='#777'; ctx.beginPath(); ctx.arc(baseX, topY-6, 6, 0, Math.PI*2); ctx.fill();
        // outline base block
        ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1; ctx.strokeRect(g.x, g.y, g.width, g.height);
        return;
      }

      if(g.type==='barn'){
        const shadowLen=lerp(3,12,t);
        const sx=Math.cos(sunlightAngle)*shadowLen;
        const sy=Math.sin(sunlightAngle)*shadowLen;
        ctx.save();
        ctx.fillStyle='#8b0000'; ctx.fillRect(g.x,g.y,g.width,g.height);
        // siding: vertical boards + subtle horizontal planks for texture
        ctx.save();
        const boardCount = Math.max(4, Math.floor(g.width / 18));
        ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.lineWidth = 1;
        for(let i=1;i<boardCount;i++){
          const bx = Math.round(g.x + i*(g.width/boardCount));
          ctx.beginPath(); ctx.moveTo(bx, g.y+6); ctx.lineTo(bx, g.y+g.height-6); ctx.stroke();
        }
        // horizontal plank seams
        ctx.strokeStyle = 'rgba(0,0,0,0.08)'; ctx.lineWidth = 1;
        const rowH = 14;
        for(let y = g.y + rowH; y < g.y + g.height - 8; y += rowH){ ctx.beginPath(); ctx.moveTo(g.x+6, y); ctx.lineTo(g.x + g.width - 6, y); ctx.stroke(); }
        ctx.restore();
        ctx.shadowColor='rgba(0,0,0,0.5)'; ctx.shadowBlur=6; ctx.shadowOffsetX=sx; ctx.shadowOffsetY=sy;
        ctx.strokeStyle='rgba(0,0,0,0.85)'; ctx.lineWidth=1; ctx.strokeRect(g.x,g.y,g.width,g.height);
        ctx.shadowColor='transparent';
        // sliding double-doors: two panels that slide sideways based on g.doorProgress
        const doorTotalW = Math.max(50, Math.floor(g.width * 0.5));
        const doorY = g.y + g.height * 0.5;
        const doorH = Math.max(40, Math.floor(g.height * 0.5));
        const leftPanelW = Math.ceil(doorTotalW / 2);
        const rightPanelW = doorTotalW - leftPanelW;
        const closedLeftX = Math.round(g.x + (g.width - doorTotalW) / 2);
        const closedRightX = closedLeftX + leftPanelW;
        const openOffsetLeft = Math.round((leftPanelW + 8) * (g.doorProgress || 0));
        const openOffsetRight = Math.round((rightPanelW + 8) * (g.doorProgress || 0));
        const leftX = closedLeftX - openOffsetLeft;
        const rightX = closedRightX + openOffsetRight;
        // opening: clear the door aperture (the gap between the panels) so the sky shows through
        const apertureLeft = leftX + leftPanelW;
        const apertureRight = rightX;
        const apertureW = apertureRight - apertureLeft;
        if(apertureW > 0){
          ctx.clearRect(apertureLeft, doorY - 2, apertureW, doorH + 4); // slight padding for cleaner look
        }

        // draw left panel
        ctx.save();
        ctx.fillStyle = shadeColorRGB([110,60,30], t*0.2);
        ctx.fillRect(leftX, doorY, leftPanelW, doorH);
        ctx.strokeStyle = 'rgba(0,0,0,0.85)'; ctx.lineWidth = 1; ctx.strokeRect(leftX, doorY, leftPanelW, doorH);
        // X brace on left panel
        ctx.strokeStyle = 'rgba(0,0,0,0.95)'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(leftX + 6, doorY + 6); ctx.lineTo(leftX + leftPanelW - 6, doorY + doorH - 6); ctx.moveTo(leftX + leftPanelW - 6, doorY + 6); ctx.lineTo(leftX + 6, doorY + doorH - 6); ctx.stroke();
        // draw right panel
        ctx.fillStyle = shadeColorRGB([110,60,30], t*0.2);
        ctx.fillRect(rightX, doorY, rightPanelW, doorH);
        ctx.strokeStyle = 'rgba(0,0,0,0.85)'; ctx.lineWidth = 1; ctx.strokeRect(rightX, doorY, rightPanelW, doorH);
        // X brace on right panel
        ctx.strokeStyle = 'rgba(0,0,0,0.95)'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(rightX + 6, doorY + 6); ctx.lineTo(rightX + rightPanelW - 6, doorY + doorH - 6); ctx.moveTo(rightX + rightPanelW - 6, doorY + 6); ctx.lineTo(rightX + 6, doorY + doorH - 6); ctx.stroke();
        // plank seams for each panel
        ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0,0,0,0.7)';
        const seamsLeft = Math.max(0, Math.floor((leftPanelW - 6) / 20));
        for(let si=1; si<=seamsLeft; si++){ const px = leftX + Math.round((leftPanelW/(seamsLeft+1))*si); ctx.beginPath(); ctx.moveTo(px, doorY + 6); ctx.lineTo(px, doorY + doorH - 6); ctx.stroke(); }
        const seamsRight = Math.max(0, Math.floor((rightPanelW - 6) / 20));
        for(let si=1; si<=seamsRight; si++){ const px = rightX + Math.round((rightPanelW/(seamsRight+1))*si); ctx.beginPath(); ctx.moveTo(px, doorY + 6); ctx.lineTo(px, doorY + doorH - 6); ctx.stroke(); }
        ctx.restore();
        ctx.fillStyle=shadeColorRGB([165,42,42], t*0.25);
        ctx.beginPath(); ctx.moveTo(g.x,g.y); ctx.lineTo(g.x+g.width/2,g.y-20); ctx.lineTo(g.x+g.width,g.y); ctx.closePath(); ctx.fill();
        ctx.strokeStyle='rgba(0,0,0,0.7)'; ctx.lineWidth=1; ctx.stroke();
        ctx.restore();
        return;
      }

      if(g.type==='silo'){
        // simple grain silo: cylindrical body with dome top and base shadow
        ctx.save();
        const bodyW = g.width, bodyH = g.height;
        const bx = g.x, by = g.y;
        // shadow on ground
        ctx.fillStyle='rgba(0,0,0,0.18)'; ctx.beginPath(); ctx.ellipse(bx+bodyW*0.5+sx, by+bodyH+6+sy, bodyW*0.6, bodyW*0.18, 0,0,Math.PI*2); ctx.fill();
        // body
        const baseColor = shadeColorRGB([190,190,200], t*0.08);
        ctx.fillStyle = baseColor; ctx.fillRect(bx, by, bodyW, bodyH);

        // ladder on the side (right side) - vertical rails + rungs
        const ladderX = Math.round(bx + bodyW*0.82);
        const railOffset = 4;
        ctx.strokeStyle = 'rgba(70,70,80,0.95)'; ctx.lineWidth = 2;
        // rails
        ctx.beginPath(); ctx.moveTo(ladderX-railOffset, by+8); ctx.lineTo(ladderX-railOffset, by+bodyH-8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ladderX+railOffset, by+8); ctx.lineTo(ladderX+railOffset, by+bodyH-8); ctx.stroke();
        // rungs
        ctx.lineWidth = 1.5;
        for(let ry = by+14; ry < by + bodyH - 10; ry += 12){ ctx.beginPath(); ctx.moveTo(ladderX-railOffset, ry); ctx.lineTo(ladderX+railOffset, ry); ctx.stroke(); }

        // top ellipse (slightly larger vertical radius to make a rounder dome)
        ctx.fillStyle = shadeColorRGB([210,210,220], t*0.04);
        ctx.beginPath(); ctx.ellipse(bx+bodyW*0.5, by+6, bodyW*0.56, 12, 0, 0, Math.PI*2); ctx.fill();
        // subtle rim highlight
        ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.lineWidth=1; ctx.beginPath(); ctx.ellipse(bx+bodyW*0.5, by+4, bodyW*0.52, 6, 0, 0, Math.PI*2); ctx.stroke();

        // bands
        ctx.strokeStyle='rgba(0,0,0,0.08)'; ctx.lineWidth=1; for(let y=by+12;y<by+bodyH-6;y+=12){ ctx.beginPath(); ctx.moveTo(bx+6,y); ctx.lineTo(bx+bodyW-6,y); ctx.stroke(); }
        // outline
        ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1; ctx.strokeRect(bx, by, bodyW, bodyH);
        ctx.restore();
        return;
      }

      if(g.type==='water'){
        // municipal water tower: tall legs and a tank on top
        ctx.save();
        const wx = g.x, wy = g.y, ww = g.width, wh = g.height;
        // legs
        const legW = Math.max(3, Math.round(ww*0.12));
        const legH = Math.round(wh*0.7);
        ctx.strokeStyle='rgba(0,0,0,0.55)'; ctx.lineWidth=2;
        const lx1 = wx+ww*0.25, lx2 = wx+ww*0.75; const legTop = wy + (wh - legH);
        ctx.beginPath(); ctx.moveTo(lx1, wy+wh); ctx.lineTo(lx1 - 8, legTop); ctx.lineTo(lx1, legTop); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(lx2, wy+wh); ctx.lineTo(lx2 + 8, legTop); ctx.lineTo(lx2, legTop); ctx.stroke();
        // central support
        ctx.beginPath(); ctx.moveTo(wx+ww*0.5, wy+wh); ctx.lineTo(wx+ww*0.5, legTop+4); ctx.stroke();
        // tank: make the top rounder (taller dome) and add smoother shading
        const tankW = ww * 1.2; const tankH = Math.max(18, Math.round(wh*0.16));
        const tankX = Math.round(wx + (ww - tankW)/2);
        const tankY = legTop - tankH - 6; // shift up a bit for bigger dome
        // dome (upper cap) with larger vertical radius for a rounder look
        const domeRadiusY = 14; const domeRadiusX = tankW*0.52;
        // glossy gradient for tank
        const tankGrad = ctx.createLinearGradient(tankX, tankY, tankX, tankY + tankH + domeRadiusY);
        tankGrad.addColorStop(0, lerpColor([230,240,250],[200,220,230], t*0.2));
        tankGrad.addColorStop(0.4, lerpColor([200,220,230],[170,190,200], t*0.08));
        tankGrad.addColorStop(1, lerpColor([160,180,200],[140,160,180], t*0.02));
        ctx.fillStyle = tankGrad;
        // dome
        ctx.beginPath(); ctx.ellipse(tankX + tankW*0.5, tankY + domeRadiusY, domeRadiusX, domeRadiusY, 0, Math.PI, 0, true); ctx.fill();
        // body
        ctx.fillRect(tankX, tankY + domeRadiusY, tankW, tankH);
        // bottom rim ellipse
        ctx.beginPath(); ctx.ellipse(tankX + tankW*0.5, tankY + domeRadiusY + tankH, domeRadiusX, domeRadiusY*0.6, 0, 0, Math.PI*2); ctx.fill();
        // rim highlight
        ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.lineWidth=1; ctx.beginPath(); ctx.ellipse(tankX + tankW*0.5, tankY + domeRadiusY-2, domeRadiusX*0.92, domeRadiusY*0.82, 0, Math.PI*0.1, Math.PI*0.9); ctx.stroke();
        ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1; ctx.strokeRect(tankX, tankY + domeRadiusY, tankW, tankH);
        ctx.restore();
        return;
      }

      if(g.type==='horse'){
        const bob=Math.sin(frameCount*0.1 + g.phase)*2;
        const legPhase=(frameCount*0.2 + g.phase);
        const legOffset=Math.sin(legPhase)*2;
        const yBase=g.y + bob;
        ctx.fillStyle='#654321'; ctx.fillRect(g.x, yBase+g.height*0.4, g.width, g.height*0.6);
        ctx.strokeStyle='rgba(0,0,0,0.7)'; ctx.lineWidth=1; ctx.strokeRect(g.x, yBase+g.height*0.4, g.width, g.height*0.6);
        const nx=g.x+g.width*0.15, ny=yBase+g.height*0.1, nw=g.width*0.35, nh=g.height*0.4;
        ctx.fillStyle='#4b3621'; ctx.fillRect(nx, ny, nw, nh);
        ctx.strokeRect(nx, ny, nw, nh);
        ctx.fillStyle='#3b2a1a'; for(let i=0;i<4;i++){ const px=nx + i*(nw/4); const flick=4 + 3*Math.max(0, Math.sin(frameCount*0.3 + g.phase + i)); ctx.beginPath(); ctx.moveTo(px,ny); ctx.lineTo(px+nw/8,ny-flick); ctx.lineTo(px+nw/4,ny); ctx.closePath(); ctx.fill(); }
        ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(g.x+g.width*0.45, yBase+g.height*0.05, 3, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle='#4b3621';
        for(let i=0;i<4;i++){ const lx=g.x+g.width*(0.1+0.25*i/3); ctx.fillRect(lx+legOffset, yBase+g.height*0.9, 3, g.height*0.1); if(frameCount%8===0 && Math.random()<0.3){ dustParticles.push({x:lx+legOffset, y:yBase+g.height, size:2+Math.random()*2, alpha:1, vy:-0.5-Math.random()}); } }
        const rx=g.x, ry=yBase+g.height*0.45, sway=Math.sin(frameCount*0.25 + g.phase)*(g.height*0.08);
        ctx.strokeStyle='#3b2a1a'; ctx.lineWidth=3; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(rx,ry); ctx.quadraticCurveTo(rx-g.width*0.15, ry+sway, rx-g.width*0.35, ry+sway*1.5); ctx.stroke();
        ctx.strokeStyle='#000'; ctx.lineWidth=1; ctx.strokeRect(g.x,yBase,g.width,g.height);
        return;
      }

      // default block (fallback)
      ctx.fillStyle='#8B4513'; ctx.fillRect(g.x,g.y,g.width,g.height);
    }

    function updateDust(speed){
      for(const p of dustParticles){ p.x-=speed; p.y+=p.vy; p.alpha-=0.02; }
      dustParticles=dustParticles.filter(p=>p.alpha>0);
      ctx.fillStyle='rgba(139,69,19,0.5)';
      for(const p of dustParticles){ ctx.globalAlpha=p.alpha; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
    }

    // === Plane ===
    function drawPlane(){
      ctx.save(); ctx.translate(plane.x,plane.y);
      // apply tilt/rotation from controls (plane.angle)
      ctx.rotate(plane.angle);
      // fuselage
      ctx.fillStyle='#c33'; ctx.beginPath(); ctx.ellipse(0,0,35,10,0,0,Math.PI*2); ctx.fill();
      // wings
      ctx.fillStyle='#b00'; ctx.fillRect(-30,-20,60,5); ctx.fillRect(-30,15,60,5);
      // tail
      ctx.fillStyle='#a00'; ctx.fillRect(-40,-5,10,10); ctx.beginPath(); ctx.moveTo(-45,0); ctx.lineTo(-55,-10); ctx.lineTo(-55,10); ctx.closePath(); ctx.fill();
      // gear
      ctx.strokeStyle='#222'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(-15,15); ctx.lineTo(-20,30); ctx.moveTo(15,15); ctx.lineTo(20,30); ctx.stroke();
      ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(-20,32,4,0,Math.PI*2); ctx.arc(20,32,4,0,Math.PI*2); ctx.fill();
      // propeller
      plane.propAngle+=0.3; ctx.save(); ctx.translate(35,0); ctx.rotate(plane.propAngle); ctx.strokeStyle='#222'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.moveTo(0,-10); ctx.lineTo(0,10); ctx.stroke(); ctx.restore();
      ctx.restore();
    }

    function drawRings(){
      ctx.save();
      ctx.font='12px system-ui, sans-serif';
      ctx.fillStyle='#222';
      for(const r of rings){
        if(!r.collected){ r.glow=(r.glow+0.06)%1; const a=0.5+0.5*Math.sin(r.glow*Math.PI*2); ctx.strokeStyle=`rgba(255,255,0,${0.6+0.4*a})`; ctx.lineWidth=4+2*a; }
        else { ctx.strokeStyle='rgba(255,255,0,0.25)'; ctx.lineWidth=2; }
        ctx.beginPath(); ctx.arc(r.x,r.y,r.radius,0,Math.PI*2); ctx.stroke();
        if(!r.collected){ ctx.fillText(r.name, r.x-18, r.y-r.radius-6); }
      }
      ctx.restore();
    }

    function checkRingCollisions(){
      for(const r of rings){
        if(!r.collected){
          const dx = plane.x - r.x;
          const dy = plane.y - r.y;
          if(Math.hypot(dx,dy) < r.radius){
            r.collected = true;
            r.glow = 0;
            playChime();
          }
        }
      }
      // remove collected rings after a short delay / when offscreen
      rings = rings.filter(r => !(r.collected && (r.x < -r.radius)) );
    }

    function crashPlane(){
      if(!plane.alive) return;
      plane.alive = false;
      plane.crashed = true;
      plane.propAngle = 0;
      paused = true;
      try{ playChime(); }catch(e){}
      // spawn crash dust
      for(let i=0;i<20;i++){ dustParticles.push({x:plane.x + (Math.random()*80-40), y:plane.y + (Math.random()*40-20), size:2+Math.random()*4, alpha:1, vy:-1-Math.random()*2}); }

      // suspend audio if running
      try{ if(audioCtx && audioCtx.state==='running') audioCtx.suspend(); }catch(e){}

      // create overlay with restart button and use a snapshot of the canvas as background so the crash moment is frozen
      const existing = document.getElementById('crashOverlay');
      if(existing) existing.remove();
      const overlay = document.createElement('div');
      overlay.id = 'crashOverlay';
      overlay.style.position = 'fixed';
      overlay.style.left = '0';
      overlay.style.top = '0';
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.display = 'flex';
      overlay.style.alignItems = 'center';
      overlay.style.justifyContent = 'center';
      overlay.style.zIndex = '9999';
      // snapshot
      let snapshot = '';
      try{ snapshot = canvas.toDataURL(); }catch(e){}
      if(snapshot) overlay.style.background = `rgba(0,0,0,0.45) url('${snapshot}') center/contain no-repeat`;
      else overlay.style.background = 'rgba(0,0,0,0.45)';

      overlay.innerHTML = `
        <div style="background:rgba(255,255,255,0.96);padding:18px 24px;border-radius:12px;text-align:center;box-shadow:0 8px 30px rgba(0,0,0,0.4);">
          <div style="font-weight:800;margin-bottom:10px;color:#c00;font-size:20px;">CRASHED</div>
          <div style="margin-bottom:16px;color:#333">You collided â€” restart?</div>
          <button id="restartBtn" style="padding:8px 14px;border-radius:8px;border:0;background:#0078d4;color:#fff;cursor:pointer">Restart</button>
        </div>
      `;
      document.body.appendChild(overlay);
      const btn = document.getElementById('restartBtn');
      if(btn) btn.addEventListener('click', ()=>{ overlay.remove(); try{ if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); }catch(e){} restartGame(); });
    }

    // === World step ===
    function worldStep(speed){
      drawSky();

      // Looping with A/D: when A or D is held (exclusively), enter loop mode
      const wantLoopA = !!keys['a'] && !keys['d'];
      const wantLoopD = !!keys['d'] && !keys['a'];
      if (wantLoopA || wantLoopD) {
        const dir = wantLoopA ? -1 : 1;
        if (!plane.loop) {
          plane.loop = true;
          plane.loopDir = dir;
          plane.loopCenterY = plane.y; // center the loop where the plane currently is
          plane.loopProgress = 0;
        } else {
          plane.loopDir = dir;
        }
      } else {
        // stop looping when neither A nor D is held
        if (plane.loop) {
          plane.loop = false;
          plane.loopProgress = 0;
        }
      }

      if (plane.loop) {
        // perform circular loop motion: update progress, set angle and y along a circle
          plane.loopProgress += plane.loopDir * plane.loopSpeed;
        // keep progress in reasonable range to avoid overflow
        if (plane.loopProgress > Math.PI*2) plane.loopProgress -= Math.PI*2;
        if (plane.loopProgress < -Math.PI*2) plane.loopProgress += Math.PI*2;
        // angle follows progress so the plane rotates as it loops
        plane.angle = plane.loopProgress;
        // vertical motion along sine gives the loop effect; radius controls loop size
        plane.y = plane.loopCenterY + Math.sin(plane.loopProgress) * plane.loopRadius;
        // ensure loop keeps plane on screen vertically
        plane.y = Math.max(10, Math.min(h()-10, plane.y));
      } else {
        // input: W/S immediate, no momentum (A/D still act as alternate W/S when not looping)
        if(keys['w'] || keys['a']) plane.y -= 2;
        if(keys['s'] || keys['d']) plane.y += 2;

        // rotation handling: A/D steer the plane (tilt left/right)
        let targetAngle = 0;
        if (keys['a']) targetAngle = -0.35; // tilt up/left
        else if (keys['d']) targetAngle = 0.35; // tilt down/right
        // smooth interpolation back to center when released (slower for smoother rotation)
        plane.angle += (targetAngle - plane.angle) * 0.08;

        // clamp vertically so the plane stays on screen
        plane.y = Math.max(10, Math.min(h()-10, plane.y));
      }

      // keep the plane at a fixed on-screen X (camera); move world according to heading
      plane.x = CAMERA_X;

      // movement: compute heading velocity (based on current angle)
      const headingSpeedFactor = 0.6;
      const vx = Math.cos(plane.angle) * speed * headingSpeedFactor;
      // vy is already applied to plane.y when not looping; we don't need vy here for world scroll

      // world scroll should match plane's intended horizontal movement: increase scroll when plane points right
      const worldShift = speed + vx;

      // audio pitch modulation: alter engine oscillator frequency by speed and plane angle
      if(audioInited && engineOsc){
        try{
          const current = engineOsc.frequency.value || engineBaseFreq;
          const target = engineBaseFreq + speed * speedFreqFactor + plane.angle * angleFreqFactor;
          const clamped = Math.max(minEngineFreq, Math.min(maxEngineFreq, target));
          engineOsc.frequency.value = current + (clamped - current) * freqSmoothing;
        }catch(e){/* ignore if audio not ready */}
      }

      // progress & spawns
      distCloud+=speed; distGround+=speed; distRing+=speed;
      if(distCloud>=DIST_CLOUD){ spawnClouds(); distCloud=0; }
      if(distGround>=DIST_GROUND){ spawnGroundElements(); distGround=0; }
      if(distRing>=DIST_RING){ spawnRing(); distRing=0; }

      // scroll world (Shift only affects horizontal, not vertical)
      for(const c of clouds) c.x -= worldShift*0.6;
      for(const g of groundElements) g.x -= worldShift;
      for(const r of rings) r.x -= worldShift;
      for(const b of bullets) b.x += (b.speed - worldShift);

      // update interactive door state for barns (open when plane approaches)
      for(const g of groundElements){
        if(g.type==='barn'){
          const doorCenterY = g.y + g.height*0.8;
          const approach = (plane.x + 140 > g.x && plane.x < g.x + g.width + 40 && Math.abs(plane.y - doorCenterY) < g.height*0.6);
          g.doorTarget = approach ? 1 : 0;
          g.doorProgress = (g.doorProgress || 0) + (g.doorTarget - (g.doorProgress || 0)) * 0.14;
          // clamp
          g.doorProgress = Math.max(0, Math.min(1, g.doorProgress));
        }
      }

      // cull
      clouds=clouds.filter(c=>c.x>-c.size);
      groundElements=groundElements.filter(g=>g.x>-g.width);
      rings=rings.filter(r=>r.x>-r.radius || !r.collected);
      bullets=bullets.filter(b=>b.x < w()+40);

      // draw
      clouds.forEach(drawCloud);
      groundElements.forEach(drawGroundElement);
      updateDust(speed);
      drawRings();
      // bullets
      drawBullets();
      drawPlane();

      // plane collision checks (only when alive) -- run after drawing so snapshot captures crash moment
      if(plane.alive){
        // ground collision: if plane hits the ground surface
        const groundTop = h() - 60;
        const planeHalfH = 15;
        if(plane.y + planeHalfH >= groundTop){ crashPlane(); }

        // bounding-box collision with ground elements/buildings
        const px = plane.x - 30; const py = plane.y - 15; const pw = 60; const ph = 30;
        for(const g of groundElements){
          const gx = g.x, gy = g.y, gw = g.width, gh = g.height;
          if(px < gx + gw && px + pw > gx && py < gy + gh && py + ph > gy){
            // if it's a barn, allow passage through the door when fully open and plane is inside the door area
            if(g.type==='barn'){
              const doorTotalW = Math.max(50, Math.floor(g.width * 0.5));
              const leftPanelW = Math.ceil(doorTotalW / 2);
              const rightPanelW = doorTotalW - leftPanelW;
              const closedLeftX = Math.round(g.x + (g.width - doorTotalW) / 2);
              const closedRightX = closedLeftX + leftPanelW;
              const doorY = g.y + g.height * 0.5;
              const doorH = Math.max(40, Math.floor(g.height * 0.5));
              const openOffsetLeft = Math.round((leftPanelW + 8) * (g.doorProgress || 0));
              const openOffsetRight = Math.round((rightPanelW + 8) * (g.doorProgress || 0));
              const leftX = closedLeftX - openOffsetLeft;
              const rightX = closedRightX + openOffsetRight;
              const apertureLeft = leftX + leftPanelW;
              const apertureRight = rightX;
              const apertureW = apertureRight - apertureLeft;
              // allow passage if door is sufficiently open AND plane center X is within the aperture AND plane overlaps door vertically
              const doorOpen = (g.doorProgress || 0) > 0.3; // door must be at least 30% open
              const planeCenterX = plane.x;
              const planeCenterY = plane.y;
              const planeXInAperture = (planeCenterX > apertureLeft) && (planeCenterX < apertureRight);
              const planeYInDoor = (planeCenterY > doorY - 20) && (planeCenterY < doorY + doorH + 20);
              if(doorOpen && planeXInAperture && planeYInDoor){
                continue; // plane is centered in the aperture â€” allow passage
              }
            }
            crashPlane(); break;
          }
        }
      }

      // ring collect
      checkRingCollisions();
    }

    function update(ts){
      if(lastTime===null) lastTime = ts;
      const dt = (ts - lastTime)/1000; // seconds since last frame
      lastTime = ts;
      frameCount++;
      // advance sun based on real elapsed time for a smooth day/night cycle
      sunlightAngle += (2*Math.PI / dayDuration) * dt;
      const speed=currentScrollSpeed();
      worldStep(speed);
      if(!paused) requestAnimationFrame(update);
    }

    // seed: a few clouds & a visible farmhouse
    function seedDemo(){
      groundElements.length=0; clouds.length=0; rings.length=0; dustParticles.length=0; bullets.length=0;
      const bw=120,bh=100;
      groundElements.push({x:Math.max(40,Math.min(200,w()-bw-40)), y:h()-60-bh, width:bw, height:bh, type:'farmhouse'});
      for(let i=0;i<3;i++){ clouds.push({x:80+i*140, y:40+i*20, size:30+10*i}); }
    }
    // start demo and starfield
    seedDemo();
    generateStars(120);

    // === Audio ===
    let audioCtx=null, engineOsc=null, engineGain=null, lfoOsc=null, lfoGain=null; let audioInited=false; let muted=false;
    // engine pitch tuning
    // make the engine much lower and less warbly
    const engineBaseFreq = 70; // lower base tone (was 140)
    // previously scaled to 0.25 sensitivity; now reduce that sensitivity by 25% (i.e. *0.75)
    // resulting factors: speed: 40 * 0.25 * 0.75 = 7.5 ; angle: 60 * 0.25 * 0.75 = 11.25
    const speedFreqFactor = 7.5; // Hz per scroll-speed unit (reduced by 25%)
    const angleFreqFactor = 11.25; // Hz per radian of tilt (reduced by 25%)
    const freqSmoothing = 0.08;
    const minEngineFreq = 80;
    const maxEngineFreq = 800;
    const muteBtn=document.getElementById('mute');
    function initAudio(){
      if(audioInited) return; audioInited=true;
      audioCtx=new (window.AudioContext||window.webkitAudioContext)();
      // engine hum: sawtooth ~140Hz with gentle tremolo
      engineOsc=audioCtx.createOscillator(); engineOsc.type='sawtooth'; engineOsc.frequency.value=engineBaseFreq;
      engineGain=audioCtx.createGain(); engineGain.gain.value=0.03; // base volume (slightly lower)
      lfoOsc=audioCtx.createOscillator(); lfoOsc.type='sine'; lfoOsc.frequency.value=1.2; // slower oscillation (less warble)
      lfoGain=audioCtx.createGain(); lfoGain.gain.value=0.005; // shallower tremolo depth
      lfoOsc.connect(lfoGain); lfoGain.connect(engineGain.gain);
      engineOsc.connect(engineGain).connect(audioCtx.destination);
      engineOsc.start(); lfoOsc.start();
    }
    function setMuted(m){
      muted=m; muteBtn.textContent = muted ? 'ðŸ”‡' : 'ðŸ”Š';
      if(!audioCtx) return;
      if(muted && audioCtx.state==='running') audioCtx.suspend();
      else if(!muted && audioCtx.state==='suspended') audioCtx.resume();
    }
    muteBtn.addEventListener('click',()=>{ if(!audioInited) initAudio(); setMuted(!muted); });

    function quickBeep(freq=880, dur=0.12, vol=0.08){ if(!audioCtx||muted||audioCtx.state!=='running') return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sine'; o.frequency.value=freq; g.gain.value=vol; o.connect(g).connect(audioCtx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+dur); o.stop(audioCtx.currentTime+dur); }
    function playChime(){ quickBeep(1200,0.15,0.1); }
    function playPop(){ quickBeep(220,0.08,0.08); }

    function restartGame(){
      // clear world
      groundElements.length=0; clouds.length=0; rings.length=0; dustParticles.length=0; bullets.length=0;
      // reset plane
      plane.alive = true; plane.crashed = false; plane.angle = 0; plane.propAngle = 0; plane.loopActive = false; plane.loopProgress = 0;
      plane.y = h()/2;
      paused = false;
      // reseed a simple scene
      seedDemo();
      generateStars(120);
      // resume loop
      lastTime = null;
      requestAnimationFrame(update);
    }

    // === Bullets ===
    function fireBullet(){ bullets.push({x:plane.x+40, y:plane.y, speed:6}); playPop(); }
    function drawBullets(){ ctx.fillStyle='yellow'; for(const b of bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,2.5,0,Math.PI*2); ctx.fill(); } }

    requestAnimationFrame(update);
  </script>
</body>
</html>
